/*
Deployment script for profBIS_View

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar Icopal_profBIS "Icopal_profBIS"
:setvar DatabaseName "profBIS_View"
GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END
GO

USE [$(DatabaseName)];


GO

PRINT N'Creating [DeploymentManagers]...';


GO
CREATE ROLE [DeploymentManagers]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [EtlDevelopers]...';


GO
CREATE ROLE [EtlDevelopers]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [EtlReaders]...';


GO
CREATE ROLE [EtlReaders]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [SqlDevelopers]...';


GO
CREATE ROLE [SqlDevelopers]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_datareader', @membername = N'DeploymentManagers';


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_datareader', @membername = N'SqlDevelopers';


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_datawriter', @membername = N'DeploymentManagers';


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_datawriter', @membername = N'SqlDevelopers';


GO
PRINT N'Creating <unnamed>...';


GO
EXECUTE sp_addrolemember @rolename = N'db_owner', @membername = N'DeploymentManagers';


GO
PRINT N'Creating [etl]...';


GO
CREATE SCHEMA [etl]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log4]...';


GO
CREATE SCHEMA [log4]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log4Private]...';


GO
CREATE SCHEMA [log4Private]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log4Utils]...';


GO
CREATE SCHEMA [log4Utils]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [privy]...';


GO
CREATE SCHEMA [privy]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [stg]...';


GO
CREATE SCHEMA [stg]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [log4Private].[JournalDetail]...';


GO
CREATE TABLE [log4Private].[JournalDetail] (
    [JournalId] INT           NOT NULL,
    [ExtraInfo] VARCHAR (MAX) NULL,
    CONSTRAINT [PK_JournalDetail] PRIMARY KEY CLUSTERED ([JournalId] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4Private].[JournalControl]...';


GO
CREATE TABLE [log4Private].[JournalControl] (
    [ModuleName]  VARCHAR (255) NOT NULL,
    [OnOffSwitch] VARCHAR (3)   NOT NULL,
    CONSTRAINT [PK_JournalControl] PRIMARY KEY CLUSTERED ([ModuleName] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4Private].[Journal]...';


GO
CREATE TABLE [log4Private].[Journal] (
    [JournalId]         INT            IDENTITY (1, 1) NOT NULL,
    [UtcDate]           DATETIME       NOT NULL,
    [SystemDate]        DATETIME       NOT NULL,
    [Task]              VARCHAR (128)  NOT NULL,
    [FunctionName]      VARCHAR (256)  NOT NULL,
    [StepInFunction]    VARCHAR (128)  NOT NULL,
    [MessageText]       VARCHAR (512)  NOT NULL,
    [SeverityId]        INT            NOT NULL,
    [ExceptionId]       INT            NULL,
    [SessionId]         INT            NOT NULL,
    [ServerName]        NVARCHAR (128) NOT NULL,
    [DatabaseName]      NVARCHAR (128) NOT NULL,
    [HostName]          NVARCHAR (128) NULL,
    [ProgramName]       NVARCHAR (128) NULL,
    [NTDomain]          NVARCHAR (128) NULL,
    [NTUsername]        NVARCHAR (128) NULL,
    [LoginName]         NVARCHAR (128) NULL,
    [OriginalLoginName] NVARCHAR (128) NULL,
    [SessionLoginTime]  DATETIME       NULL,
    CONSTRAINT [PK_Journal] PRIMARY KEY CLUSTERED ([JournalId] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4Private].[SqlException]...';


GO
CREATE TABLE [log4Private].[SqlException] (
    [ExceptionId]       INT            IDENTITY (1, 1) NOT NULL,
    [UtcDate]           DATETIME       NOT NULL,
    [SystemDate]        DATETIME       NOT NULL,
    [ErrorContext]      NVARCHAR (512) NOT NULL,
    [ErrorNumber]       INT            NOT NULL,
    [ErrorSeverity]     INT            NOT NULL,
    [ErrorState]        INT            NOT NULL,
    [ErrorProcedure]    NVARCHAR (128) NOT NULL,
    [ErrorLine]         INT            NOT NULL,
    [ErrorMessage]      NVARCHAR (MAX) NOT NULL,
    [ErrorDatabase]     NVARCHAR (128) NOT NULL,
    [SessionIdent]      INT            NOT NULL,
    [ServerName]        NVARCHAR (128) NOT NULL,
    [HostName]          NVARCHAR (128) NOT NULL,
    [ProgramName]       NVARCHAR (128) NOT NULL,
    [NTDomain]          NVARCHAR (128) NOT NULL,
    [NTUsername]        NVARCHAR (128) NOT NULL,
    [LoginName]         NVARCHAR (128) NOT NULL,
    [OriginalLoginName] NVARCHAR (128) NOT NULL,
    [SessionLoginTime]  DATETIME       NULL,
    CONSTRAINT [PK_SqlException] PRIMARY KEY CLUSTERED ([ExceptionId] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [log4Private].[Severity]...';


GO
CREATE TABLE [log4Private].[Severity] (
    [SeverityId]   INT           NOT NULL,
    [SeverityName] VARCHAR (128) NOT NULL,
    CONSTRAINT [PK_Severity] PRIMARY KEY CLUSTERED ([SeverityId] ASC) WITH (FILLFACTOR = 100),
    CONSTRAINT [UQ_Severity_SeverityName] UNIQUE NONCLUSTERED ([SeverityName] ASC) WITH (FILLFACTOR = 100)
);


GO
PRINT N'Creating [privy].[StagingLoadParameter]...';


GO
CREATE TABLE [privy].[StagingLoadParameter] (
    [ModuleName]       VARCHAR (200) NOT NULL,
    [DataCaptureStart] DATETIME      NULL,
    [DataCaptureEnd]   DATETIME      NULL,
    CONSTRAINT [PK_StagingLoadParameter] PRIMARY KEY CLUSTERED ([ModuleName] ASC)
);


GO
PRINT N'Creating [stg].[CustomerCategoryHierarchy]...';


GO
CREATE TABLE [stg].[CustomerCategoryHierarchy] (
    [LeafId]        INT            NOT NULL,
    [ChildId]       INT            NOT NULL,
    [ParentId]      INT            NOT NULL,
    [RootId]        INT            NOT NULL,
    [hNodeFromLeaf] INT            NOT NULL,
    [hNodeFromRoot] BIGINT         NOT NULL,
    [LeafName]      NVARCHAR (100) NULL,
    [ChildName]     NVARCHAR (100) NULL,
    [ParentName]    NVARCHAR (100) NULL,
    [RootName]      NVARCHAR (100) NULL,
    [EtlCreatedOn]  DATETIME       NOT NULL,
    CONSTRAINT [PK_stg_CustomerCategoryHierarchy] PRIMARY KEY CLUSTERED ([LeafId] ASC, [ChildId] ASC, [ParentId] ASC)
);


GO
PRINT N'Creating [stg].[Customer]...';


GO
CREATE TABLE [stg].[Customer] (
    [CustomerKey]               INT            IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]              CHAR (32)      NOT NULL,
    [EtlCreatedOn]              DATETIME       NOT NULL,
    [EtlCreatedBy]              VARCHAR (200)  NOT NULL,
    [EtlUpdatedOn]              DATETIME       NOT NULL,
    [EtlUpdatedBy]              VARCHAR (200)  NOT NULL,
    [EtlDeletedOn]              DATETIME       NULL,
    [EtlDeletedBy]              VARCHAR (200)  NULL,
    [IsDeleted]                 CHAR (1)       NOT NULL,
    [QlikViewSourceSystemId]    INT            NOT NULL,
    [NativeCustomerKey]         NVARCHAR (50)  NOT NULL,
    [CustomerNumber]            NVARCHAR (50)  NOT NULL,
    [CustomerName]              NVARCHAR (100) NULL,
    [CustomerAddress1]          NVARCHAR (100) NULL,
    [CustomerAddress2]          NVARCHAR (100) NULL,
    [CustomerAddress3]          NVARCHAR (100) NULL,
    [CustomerZipCode]           NVARCHAR (100) NULL,
    [CustomerCity]              NVARCHAR (100) NULL,
    [CustomerCountry]           NVARCHAR (100) NULL,
    [CustomerVatNumber]         NVARCHAR (50)  NULL,
    [CustomerTypeId]            INT            NULL,
    [CustomerTypeName]          NVARCHAR (100) NULL,
    [CustomerGroup1]            NVARCHAR (100) NULL,
    [CustomerGroup2]            NVARCHAR (100) NULL,
    [CustomerGroup3]            NVARCHAR (100) NULL,
    [CustomerGroup4]            NVARCHAR (100) NULL,
    [CustomerGroup5]            NVARCHAR (100) NULL,
    [CategoryIsMapped]          CHAR (1)       NOT NULL,
    [NativeCustomerCategoryKey] NVARCHAR (100) NOT NULL,
    [CustomerCategoryBaseLevel] NVARCHAR (200) NOT NULL,
    [CustomerCategoryLevel1]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel2]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel3]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel4]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel5]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel6]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel7]    NVARCHAR (100) NULL,
    [CustomerCategoryLevel8]    NVARCHAR (100) NULL,
    CONSTRAINT [PK_stg_Customer] PRIMARY KEY CLUSTERED ([CustomerKey] ASC),
    CONSTRAINT [AK_stg_Customer_QlikViewSourceSystemId_NativeCustomerKey] UNIQUE NONCLUSTERED ([QlikViewSourceSystemId] ASC, [NativeCustomerKey] ASC)
);


GO
PRINT N'Creating [stg].[Customer].[NCI_stg_Customer_ExtractFilter]...';


GO
CREATE NONCLUSTERED INDEX [NCI_stg_Customer_ExtractFilter]
    ON [stg].[Customer]([CustomerKey] ASC, [EtlDeltaHash] ASC, [IsDeleted] ASC);


GO
PRINT N'Creating [stg].[BusinessUnitControl]...';


GO
CREATE TABLE [stg].[BusinessUnitControl] (
    [BusinessUnitKey]   INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_BusinessUnitControl] PRIMARY KEY CLUSTERED ([BusinessUnitKey] ASC)
);


GO
PRINT N'Creating [stg].[BusinessUnit]...';


GO
CREATE TABLE [stg].[BusinessUnit] (
    [BusinessUnitKey]           INT             IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]              CHAR (32)       NOT NULL,
    [EtlCreatedOn]              DATETIME        NOT NULL,
    [EtlCreatedBy]              VARCHAR (200)   NOT NULL,
    [EtlUpdatedOn]              DATETIME        NOT NULL,
    [EtlUpdatedBy]              VARCHAR (200)   NOT NULL,
    [EtlDeletedOn]              DATETIME        NULL,
    [EtlDeletedBy]              VARCHAR (200)   NULL,
    [IsDeleted]                 CHAR (1)        NOT NULL,
    [NativeBusinessUnitKey]     NVARCHAR (50)   NOT NULL,
    [StrategicBusinessUnitCode] NVARCHAR (20)   NOT NULL,
    [SalesCenterSbuCode]        NVARCHAR (20)   NOT NULL,
    [BusinessUnitName]          NVARCHAR (100)  NOT NULL,
    [RegionId]                  INT             NULL,
    [RegionName]                NVARCHAR (50)   NOT NULL,
    [RegionDescription]         NVARCHAR (1000) NOT NULL,
    CONSTRAINT [PK_stg_BusinessUnit] PRIMARY KEY CLUSTERED ([BusinessUnitKey] ASC),
    CONSTRAINT [AK_stg_BusinessUnit_NativeBusinessUnitKey] UNIQUE NONCLUSTERED ([NativeBusinessUnitKey] ASC)
);


GO
PRINT N'Creating [stg].[OrderShippedNotInvoicedControl]...';


GO
CREATE TABLE [stg].[OrderShippedNotInvoicedControl] (
    [OrderShippedNotInvoicedKey] INT       NOT NULL,
    [PreviousDeltaHash]          CHAR (32) NOT NULL,
    [IsDeleted]                  CHAR (1)  NOT NULL,
    [LastTouchedOn]              DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_OrderShippedNotInvoicedControl] PRIMARY KEY CLUSTERED ([OrderShippedNotInvoicedKey] ASC)
);


GO
PRINT N'Creating [stg].[OrderShippedNotInvoiced]...';


GO
CREATE TABLE [stg].[OrderShippedNotInvoiced] (
    [OrderShippedNotInvoicedKey] INT              IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]               CHAR (32)        NOT NULL,
    [EtlCreatedOn]               DATETIME         NOT NULL,
    [EtlCreatedBy]               VARCHAR (200)    NOT NULL,
    [EtlUpdatedOn]               DATETIME         NOT NULL,
    [EtlUpdatedBy]               VARCHAR (200)    NOT NULL,
    [EtlDeletedOn]               DATETIME         NULL,
    [EtlDeletedBy]               VARCHAR (200)    NULL,
    [IsDeleted]                  CHAR (1)         NOT NULL,
    [REC_ID]                     UNIQUEIDENTIFIER NOT NULL,
    [SYSTEM_ID]                  INT              NOT NULL,
    [ORDER_NUMBER]               NVARCHAR (50)    NOT NULL,
    [ORDER_LINE_NUMBER]          NVARCHAR (50)    NOT NULL,
    [SHIPPING_DOCUMENT]          NVARCHAR (50)    NOT NULL,
    [Uniqueifier]                BIGINT           NOT NULL,
    [EXPECTED_INVOICE_DATE]      DATETIME         NOT NULL,
    [ORDER_TYPE]                 NVARCHAR (1)     NOT NULL,
    [OrderTypeName]              NVARCHAR (50)    NOT NULL,
    [LOCAL_SITE_SOLD]            NVARCHAR (50)    NOT NULL,
    [SITE_ID]                    INT              NULL,
    [ITEM_NO]                    NVARCHAR (20)    NOT NULL,
    [ITEM_CATEGORY_ID]           INT              NULL,
    [ENV_CATEGORY_ID]            INT              NULL,
    [SOLD_TO_CUSTOMER_NO]        NVARCHAR (50)    NOT NULL,
    [SHIP_TO_CUSTOMER_NO]        NVARCHAR (50)    NOT NULL,
    [SALESPERSON_ID]             NVARCHAR (50)    NOT NULL,
    [SALESPERSON_NAME]           NVARCHAR (100)   NOT NULL,
    [SHIPPED_QUANTITY]           DECIMAL (12, 2)  NULL,
    [SHIPPED_UOM]                NVARCHAR (20)    NOT NULL,
    [STATISTIC_QUANTITY]         DECIMAL (12, 2)  NULL,
    [STATISTIC_UOM]              NVARCHAR (20)    NOT NULL,
    [QUANTITY]                   DECIMAL (12, 2)  NULL,
    [LOCAL_UOM]                  NVARCHAR (20)    NOT NULL,
    [LOCAL_UOM_HARMONIZED]       NVARCHAR (20)    NOT NULL,
    [LOCAL_UOM_FACTOR]           DECIMAL (11, 4)  NULL,
    [SHIPPED_AMOUNT]             DECIMAL (15, 4)  NULL,
    [LOCAL_AMOUNT]               DECIMAL (15, 4)  NULL,
    [GROUP_AMOUNT]               DECIMAL (15, 4)  NULL,
    [SHIPPED_CURRENCY]           NVARCHAR (3)     NOT NULL,
    [LOCAL_CURRENCY]             NVARCHAR (3)     NOT NULL,
    [LINE_DISCOUNT_AMOUNT]       DECIMAL (15, 4)  NULL,
    [ORDER_DISCOUNT_AMOUNT]      DECIMAL (15, 4)  NULL,
    [LINE_BONUS_AMOUNT]          DECIMAL (15, 4)  NULL,
    [BONUS_SHARE_AMOUNT]         DECIMAL (15, 4)  NULL,
    CONSTRAINT [PK_stg_OrderShippedNotInvoiced] PRIMARY KEY CLUSTERED ([OrderShippedNotInvoicedKey] ASC),
    CONSTRAINT [AK_stg_OrderShippedNotInvoiced_REC_ID] UNIQUE NONCLUSTERED ([REC_ID] ASC),
    CONSTRAINT [AK_stg_OrderShippedNotInvoiced_UniqueifiedBusinessKey] UNIQUE NONCLUSTERED ([SYSTEM_ID] ASC, [ORDER_NUMBER] ASC, [ORDER_LINE_NUMBER] ASC, [SHIPPING_DOCUMENT] ASC, [Uniqueifier] ASC)
);


GO
PRINT N'Creating [stg].[OrderBacklogControl]...';


GO
CREATE TABLE [stg].[OrderBacklogControl] (
    [OrderBacklogKey]   INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_OrderBacklogControl] PRIMARY KEY CLUSTERED ([OrderBacklogKey] ASC)
);


GO
PRINT N'Creating [stg].[OrderBacklog]...';


GO
CREATE TABLE [stg].[OrderBacklog] (
    [OrderBacklogKey]       INT              IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]          CHAR (32)        NOT NULL,
    [EtlCreatedOn]          DATETIME         NOT NULL,
    [EtlCreatedBy]          VARCHAR (200)    NOT NULL,
    [EtlUpdatedOn]          DATETIME         NOT NULL,
    [EtlUpdatedBy]          VARCHAR (200)    NOT NULL,
    [EtlDeletedOn]          DATETIME         NULL,
    [EtlDeletedBy]          VARCHAR (200)    NULL,
    [IsDeleted]             CHAR (1)         NOT NULL,
    [REC_ID]                UNIQUEIDENTIFIER NOT NULL,
    [SYSTEM_ID]             INT              NOT NULL,
    [ORDER_NUMBER]          NVARCHAR (50)    NOT NULL,
    [ORDER_LINE_NUMBER]     NVARCHAR (50)    NOT NULL,
    [Uniqueifier]           BIGINT           NOT NULL,
    [EXPECTED_INVOICE_DATE] DATETIME         NOT NULL,
    [ORDER_TYPE]            NVARCHAR (1)     NOT NULL,
    [OrderTypeName]         NVARCHAR (50)    NOT NULL,
    [LOCAL_SITE_SOLD]       NVARCHAR (50)    NOT NULL,
    [SITE_ID]               INT              NULL,
    [ITEM_NO]               NVARCHAR (20)    NOT NULL,
    [ITEM_CATEGORY_ID]      INT              NULL,
    [ENV_CATEGORY_ID]       INT              NULL,
    [SOLD_TO_CUSTOMER_NO]   NVARCHAR (50)    NOT NULL,
    [SHIP_TO_CUSTOMER_NO]   NVARCHAR (50)    NOT NULL,
    [SALESPERSON_ID]        NVARCHAR (50)    NOT NULL,
    [SALESPERSON_NAME]      NVARCHAR (100)   NOT NULL,
    [ORDER_QUANTITY]        DECIMAL (12, 2)  NULL,
    [ORDER_UOM]             NVARCHAR (20)    NOT NULL,
    [STATISTIC_QUANTITY]    DECIMAL (12, 2)  NULL,
    [STATISTIC_UOM]         NVARCHAR (20)    NOT NULL,
    [QUANTITY]              DECIMAL (12, 2)  NULL,
    [LOCAL_UOM]             NVARCHAR (20)    NOT NULL,
    [LOCAL_UOM_HARMONIZED]  NVARCHAR (20)    NOT NULL,
    [LOCAL_UOM_FACTOR]      DECIMAL (11, 4)  NULL,
    [ORDER_AMOUNT]          DECIMAL (15, 4)  NULL,
    [LOCAL_AMOUNT]          DECIMAL (15, 4)  NULL,
    [GROUP_AMOUNT]          DECIMAL (15, 4)  NULL,
    [ORDER_CURRENCY]        NVARCHAR (3)     NOT NULL,
    [LOCAL_CURRENCY]        NVARCHAR (3)     NOT NULL,
    [LINE_DISCOUNT_AMOUNT]  DECIMAL (15, 4)  NULL,
    [ORDER_DISCOUNT_AMOUNT] DECIMAL (15, 4)  NULL,
    [LINE_BONUS_AMOUNT]     DECIMAL (15, 4)  NULL,
    [BONUS_SHARE_AMOUNT]    DECIMAL (15, 4)  NULL,
    CONSTRAINT [PK_stg_OrderBacklog] PRIMARY KEY CLUSTERED ([OrderBacklogKey] ASC),
    CONSTRAINT [AK_stg_OrderBacklog_UniqueifiedBusinessKey] UNIQUE NONCLUSTERED ([SYSTEM_ID] ASC, [ORDER_NUMBER] ASC, [ORDER_LINE_NUMBER] ASC, [Uniqueifier] ASC)
);


GO
PRINT N'Creating [stg].[InvoiceControl]...';


GO
CREATE TABLE [stg].[InvoiceControl] (
    [InvoiceKey]        INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_InvoiceControl] PRIMARY KEY CLUSTERED ([InvoiceKey] ASC)
);


GO
PRINT N'Creating [stg].[Invoice]...';


GO
CREATE TABLE [stg].[Invoice] (
    [InvoiceKey]               INT              IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]             CHAR (32)        NOT NULL,
    [EtlCreatedOn]             DATETIME         NOT NULL,
    [EtlCreatedBy]             VARCHAR (200)    NOT NULL,
    [EtlUpdatedOn]             DATETIME         NOT NULL,
    [EtlUpdatedBy]             VARCHAR (200)    NOT NULL,
    [EtlDeletedOn]             DATETIME         NULL,
    [EtlDeletedBy]             VARCHAR (200)    NULL,
    [IsDeleted]                CHAR (1)         NOT NULL,
    [REC_ID]                   UNIQUEIDENTIFIER NOT NULL,
    [SYSTEM_ID]                INT              NOT NULL,
    [INVOICE_DATE]             DATETIME         NOT NULL,
    [INVOICE_NUMBER]           NVARCHAR (20)    NOT NULL,
    [INVOICE_LINE_NUMBER]      NVARCHAR (20)    NOT NULL,
    [ORDER_NUMBER]             NVARCHAR (20)    NOT NULL,
    [ORDER_LINE_NUMBER]        NVARCHAR (20)    NOT NULL,
    [Uniqueifier]              BIGINT           NOT NULL,
    [INVOICE_TYPE]             NVARCHAR (1)     NOT NULL,
    [InvoiceTypeName]          NVARCHAR (29)    NOT NULL,
    [LOCAL_SITE_SOLD]          NVARCHAR (20)    NOT NULL,
    [SITE_ID]                  INT              NOT NULL,
    [ITEM_NO]                  NVARCHAR (50)    NOT NULL,
    [ITEM_CATEGORY_ID]         INT              NULL,
    [ENV_CATEGORY_ID]          INT              NULL,
    [SOLD_TO_CUSTOMER_NO]      NVARCHAR (20)    NOT NULL,
    [SHIP_TO_CUSTOMER_NO]      NVARCHAR (20)    NOT NULL,
    [SALESPERSON_ID]           NVARCHAR (20)    NOT NULL,
    [SALESPERSON_NAME]         NVARCHAR (100)   NOT NULL,
    [DELIVERY_DATE]            DATETIME         NULL,
    [EXPECTED_PAYMENT_DATE]    DATETIME         NULL,
    [ACTUAL_PAYMENT_DATE]      DATETIME         NULL,
    [LOCAL_DELIVERY_TERM]      NVARCHAR (20)    NOT NULL,
    [LOCAL_DELIVERY_TERM_TEXT] NVARCHAR (100)   NOT NULL,
    [PAYMENT_TERM_ID]          INT              NULL,
    [LOCAL_PAYMENT_TERM]       NVARCHAR (20)    NOT NULL,
    [LOCAL_PAYMENT_TERM_TEXT]  NVARCHAR (100)   NOT NULL,
    [INVOICE_QUANTITY]         DECIMAL (12, 2)  NULL,
    [INVOICE_UOM]              NVARCHAR (20)    NOT NULL,
    [STATISTIC_QUANTITY]       DECIMAL (12, 2)  NULL,
    [STATISTIC_UOM]            NVARCHAR (20)    NOT NULL,
    [QUANTITY]                 DECIMAL (12, 2)  NULL,
    [LOCAL_UOM]                NVARCHAR (20)    NOT NULL,
    [LOCAL_UOM_HARMONIZED]     NVARCHAR (20)    NOT NULL,
    [LOCAL_UOM_FACTOR]         DECIMAL (11, 4)  NULL,
    [INVOICE_AMOUNT]           DECIMAL (15, 4)  NULL,
    [LOCAL_AMOUNT]             DECIMAL (15, 4)  NULL,
    [GROUP_AMOUNT]             DECIMAL (15, 4)  NULL,
    [INVOICE_CURRENCY]         NVARCHAR (3)     NOT NULL,
    [LOCAL_CURRENCY]           NVARCHAR (3)     NULL,
    [LINE_DISCOUNT_AMOUNT]     DECIMAL (15, 4)  NULL,
    [INVOICE_DISCOUNT_AMOUNT]  DECIMAL (15, 4)  NULL,
    [LINE_BONUS_AMOUNT]        DECIMAL (15, 4)  NULL,
    [BONUS_SHARE_AMOUNT]       DECIMAL (15, 4)  NULL,
    [STD_COST]                 DECIMAL (15, 4)  NULL,
    [STD_FREIGHT]              DECIMAL (15, 4)  NULL,
    CONSTRAINT [PK_stg_Invoice] PRIMARY KEY CLUSTERED ([InvoiceKey] ASC),
    CONSTRAINT [AK_stg_Invoice_UniqueifiedBusinessKey] UNIQUE NONCLUSTERED ([SYSTEM_ID] ASC, [INVOICE_NUMBER] ASC, [ORDER_NUMBER] ASC, [INVOICE_LINE_NUMBER] ASC, [ORDER_LINE_NUMBER] ASC, [Uniqueifier] ASC)
);


GO
PRINT N'Creating [stg].[Invoice].[NCI_stg_InvoiceControl_ExtractFilter]...';


GO
CREATE NONCLUSTERED INDEX [NCI_stg_InvoiceControl_ExtractFilter]
    ON [stg].[Invoice]([InvoiceKey] ASC, [EtlDeltaHash] ASC, [IsDeleted] ASC);


GO
PRINT N'Creating [stg].[Invoice].[NCI_stg_Invoice_ExtractFilter]...';


GO
CREATE NONCLUSTERED INDEX [NCI_stg_Invoice_ExtractFilter]
    ON [stg].[Invoice]([InvoiceKey] ASC, [EtlDeltaHash] ASC, [IsDeleted] ASC, [Uniqueifier] ASC);


GO
PRINT N'Creating [stg].[CustomerControl]...';


GO
CREATE TABLE [stg].[CustomerControl] (
    [CustomerKey]       INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_CustomerControl] PRIMARY KEY CLUSTERED ([CustomerKey] ASC)
);


GO
PRINT N'Creating [stg].[Site]...';


GO
CREATE TABLE [stg].[Site] (
    [SiteKey]                   INT             IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]              CHAR (32)       NOT NULL,
    [EtlCreatedOn]              DATETIME        NOT NULL,
    [EtlCreatedBy]              VARCHAR (200)   NOT NULL,
    [EtlUpdatedOn]              DATETIME        NOT NULL,
    [EtlUpdatedBy]              VARCHAR (200)   NOT NULL,
    [EtlDeletedOn]              DATETIME        NULL,
    [EtlDeletedBy]              VARCHAR (200)   NULL,
    [IsDeleted]                 CHAR (1)        NOT NULL,
    [NativeSiteKey]             NVARCHAR (50)   NOT NULL,
    [SiteName]                  NVARCHAR (100)  NOT NULL,
    [SiteDescription]           NVARCHAR (1000) NOT NULL,
    [StrategicBusinessUnitCode] NVARCHAR (20)   NOT NULL,
    [SalesCenterSbuCode]        NVARCHAR (20)   NOT NULL,
    [BusinessUnitName]          NVARCHAR (100)  NOT NULL,
    [RegionId]                  INT             NULL,
    [RegionName]                NVARCHAR (50)   NOT NULL,
    [RegionDescription]         NVARCHAR (1000) NOT NULL,
    [SourceSystemId]            INT             NULL,
    [SourceSystemName]          NVARCHAR (100)  NOT NULL,
    CONSTRAINT [PK_stg_Site] PRIMARY KEY CLUSTERED ([SiteKey] ASC),
    CONSTRAINT [AK_stg_Site_NativeSiteKey] UNIQUE NONCLUSTERED ([NativeSiteKey] ASC)
);


GO
PRINT N'Creating [stg].[ProductControl]...';


GO
CREATE TABLE [stg].[ProductControl] (
    [ProductKey]        INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_ProductControl] PRIMARY KEY CLUSTERED ([ProductKey] ASC)
);


GO
PRINT N'Creating [stg].[ProductCategoryHierarchy]...';


GO
CREATE TABLE [stg].[ProductCategoryHierarchy] (
    [LeafId]        INT            NOT NULL,
    [ChildId]       INT            NOT NULL,
    [ParentId]      INT            NOT NULL,
    [RootId]        INT            NOT NULL,
    [hNodeFromLeaf] INT            NOT NULL,
    [hNodeFromRoot] BIGINT         NOT NULL,
    [LeafName]      NVARCHAR (100) NULL,
    [ChildName]     NVARCHAR (100) NULL,
    [ParentName]    NVARCHAR (100) NULL,
    [RootName]      NVARCHAR (100) NULL,
    [EtlCreatedOn]  DATETIME       NOT NULL,
    CONSTRAINT [PK_stg_ProductCategoryHierarchy] PRIMARY KEY CLUSTERED ([LeafId] ASC, [ChildId] ASC, [ParentId] ASC)
);


GO
PRINT N'Creating [stg].[ProductCategoryControl]...';


GO
CREATE TABLE [stg].[ProductCategoryControl] (
    [ProductCategoryKey] INT       NOT NULL,
    [PreviousDeltaHash]  CHAR (32) NOT NULL,
    [IsDeleted]          CHAR (1)  NOT NULL,
    [LastTouchedOn]      DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_ProductCategoryControl] PRIMARY KEY CLUSTERED ([ProductCategoryKey] ASC)
);


GO
PRINT N'Creating [stg].[ProductCategory]...';


GO
CREATE TABLE [stg].[ProductCategory] (
    [ProductCategoryKey]         INT            IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]               CHAR (32)      NOT NULL,
    [EtlCreatedOn]               DATETIME       NOT NULL,
    [EtlCreatedBy]               VARCHAR (200)  NOT NULL,
    [EtlUpdatedOn]               DATETIME       NOT NULL,
    [EtlUpdatedBy]               VARCHAR (200)  NOT NULL,
    [EtlDeletedOn]               DATETIME       NULL,
    [EtlDeletedBy]               VARCHAR (200)  NULL,
    [IsDeleted]                  CHAR (1)       NOT NULL,
    [NativeProductCategoryKey]   NVARCHAR (50)  NOT NULL,
    [ProductCategoryId]          INT            NOT NULL,
    [ProductCategoryName]        NVARCHAR (100) NOT NULL,
    [NodeDepth]                  TINYINT        NOT NULL,
    [Level3Id]                   INT            NOT NULL,
    [Level3Name]                 NVARCHAR (100) NOT NULL,
    [Level2Id]                   INT            NOT NULL,
    [Level2Name]                 NVARCHAR (100) NOT NULL,
    [Level1Id]                   INT            NOT NULL,
    [Level1Name]                 NVARCHAR (100) NOT NULL,
    [ProductCategoryDescription] NVARCHAR (500) NOT NULL,
    CONSTRAINT [PK_stg_ProductCategory] PRIMARY KEY CLUSTERED ([ProductCategoryKey] ASC),
    CONSTRAINT [AK_stg_ProductCategory_NativeProductCategoryKey] UNIQUE NONCLUSTERED ([NativeProductCategoryKey] ASC)
);


GO
PRINT N'Creating [stg].[Product]...';


GO
CREATE TABLE [stg].[Product] (
    [ProductKey]               INT            IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]             CHAR (32)      NOT NULL,
    [EtlCreatedOn]             DATETIME       NOT NULL,
    [EtlCreatedBy]             VARCHAR (200)  NOT NULL,
    [EtlUpdatedOn]             DATETIME       NOT NULL,
    [EtlUpdatedBy]             VARCHAR (200)  NOT NULL,
    [EtlDeletedOn]             DATETIME       NULL,
    [EtlDeletedBy]             VARCHAR (200)  NULL,
    [IsDeleted]                CHAR (1)       NOT NULL,
    [QlikViewSourceSystemId]   INT            NOT NULL,
    [NativeProductKey]         NVARCHAR (50)  NOT NULL,
    [ProductNumber]            NVARCHAR (50)  NOT NULL,
    [ProductName]              NVARCHAR (100) NOT NULL,
    [ProductTypeId]            INT            NULL,
    [ProductTypeName]          NVARCHAR (50)  NOT NULL,
    [ProductGnit]              NVARCHAR (50)  NOT NULL,
    [ProductDescription1]      NVARCHAR (100) NOT NULL,
    [ProductDescription2]      NVARCHAR (100) NOT NULL,
    [LocalProductGroup1]       NVARCHAR (50)  NOT NULL,
    [LocalProductGroup2]       NVARCHAR (50)  NOT NULL,
    [LocalProductGroup3]       NVARCHAR (50)  NOT NULL,
    [LocalProductGroup4]       NVARCHAR (50)  NOT NULL,
    [LocalProductGroup5]       NVARCHAR (50)  NOT NULL,
    [NativeProductCategoryKey] NVARCHAR (100) NOT NULL,
    [ProductCategoryBaseLevel] NVARCHAR (200) NOT NULL,
    [ProductCategoryLevel1Id]  INT            NULL,
    [ProductCategoryLevel1]    NVARCHAR (200) NOT NULL,
    [ProductCategoryLevel2Id]  INT            NULL,
    [ProductCategoryLevel2]    NVARCHAR (200) NOT NULL,
    [ProductCategoryLevel3Id]  INT            NULL,
    [ProductCategoryLevel3]    NVARCHAR (200) NOT NULL,
    [ProductCategoryLevel4Id]  INT            NULL,
    [ProductCategoryLevel4]    NVARCHAR (200) NOT NULL,
    [ProductCategoryLevel5Id]  INT            NULL,
    [ProductCategoryLevel5]    NVARCHAR (200) NOT NULL,
    [ProductCategoryLevel6Id]  INT            NULL,
    [ProductCategoryLevel6]    NVARCHAR (200) NOT NULL,
    CONSTRAINT [PK_stg_Product] PRIMARY KEY CLUSTERED ([ProductKey] ASC),
    CONSTRAINT [AK_stg_Product_QlikViewSourceSystemId_NativeProductKey] UNIQUE NONCLUSTERED ([QlikViewSourceSystemId] ASC, [NativeProductKey] ASC)
);


GO
PRINT N'Creating [stg].[Product].[NCI_stg_Product_ExtractFilter]...';


GO
CREATE NONCLUSTERED INDEX [NCI_stg_Product_ExtractFilter]
    ON [stg].[Product]([ProductKey] ASC, [EtlDeltaHash] ASC, [IsDeleted] ASC);


GO
PRINT N'Creating [stg].[PaymentTermControl]...';


GO
CREATE TABLE [stg].[PaymentTermControl] (
    [PaymentTermKey]    INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_PaymentTermControl] PRIMARY KEY CLUSTERED ([PaymentTermKey] ASC)
);


GO
PRINT N'Creating [stg].[PaymentTerm]...';


GO
CREATE TABLE [stg].[PaymentTerm] (
    [PaymentTermKey]         INT            IDENTITY (100, 1) NOT NULL,
    [EtlDeltaHash]           CHAR (32)      NOT NULL,
    [EtlCreatedOn]           DATETIME       NOT NULL,
    [EtlCreatedBy]           VARCHAR (200)  NOT NULL,
    [EtlUpdatedOn]           DATETIME       NOT NULL,
    [EtlUpdatedBy]           VARCHAR (200)  NOT NULL,
    [EtlDeletedOn]           DATETIME       NULL,
    [EtlDeletedBy]           VARCHAR (200)  NULL,
    [IsDeleted]              CHAR (1)       NOT NULL,
    [NativePaymentTermKey]   NVARCHAR (50)  NOT NULL,
    [PaymentTermName]        NVARCHAR (100) NOT NULL,
    [PaymentTermDays]        INT            NULL,
    [PaymentTermDescription] NVARCHAR (500) NOT NULL,
    CONSTRAINT [PK_stg_PaymentTerm] PRIMARY KEY CLUSTERED ([PaymentTermKey] ASC),
    CONSTRAINT [AK_stg_PaymentTerm_NativePaymentTermKey] UNIQUE NONCLUSTERED ([NativePaymentTermKey] ASC)
);


GO
PRINT N'Creating [stg].[SiteControl]...';


GO
CREATE TABLE [stg].[SiteControl] (
    [SiteKey]           INT       NOT NULL,
    [PreviousDeltaHash] CHAR (32) NOT NULL,
    [IsDeleted]         CHAR (1)  NOT NULL,
    [LastTouchedOn]     DATETIME  NOT NULL,
    CONSTRAINT [PK_stg_SiteControl] PRIMARY KEY CLUSTERED ([SiteKey] ASC)
);


GO
PRINT N'Creating [log4Private].[DF_Journal_UtcDate]...';


GO
ALTER TABLE [log4Private].[Journal]
    ADD CONSTRAINT [DF_Journal_UtcDate] DEFAULT (getutcdate()) FOR [UtcDate];


GO
PRINT N'Creating [log4Private].[DF_Journal_SystemDate]...';


GO
ALTER TABLE [log4Private].[Journal]
    ADD CONSTRAINT [DF_Journal_SystemDate] DEFAULT (getdate()) FOR [SystemDate];


GO
PRINT N'Creating [log4Private].[DF_Journal_Task]...';


GO
ALTER TABLE [log4Private].[Journal]
    ADD CONSTRAINT [DF_Journal_Task] DEFAULT ('') FOR [Task];


GO
PRINT N'Creating [log4Private].[DF_SqlException_UtcDate]...';


GO
ALTER TABLE [log4Private].[SqlException]
    ADD CONSTRAINT [DF_SqlException_UtcDate] DEFAULT (getutcdate()) FOR [UtcDate];


GO
PRINT N'Creating [log4Private].[DF_SqlException_SystemDate]...';


GO
ALTER TABLE [log4Private].[SqlException]
    ADD CONSTRAINT [DF_SqlException_SystemDate] DEFAULT (getdate()) FOR [SystemDate];


GO
PRINT N'Creating [log4Private].[FK_JournalDetail_Journal]...';


GO
ALTER TABLE [log4Private].[JournalDetail]
    ADD CONSTRAINT [FK_JournalDetail_Journal] FOREIGN KEY ([JournalId]) REFERENCES [log4Private].[Journal] ([JournalId]) ON DELETE CASCADE;


GO
PRINT N'Creating [log4Private].[FK_Journal_Severity]...';


GO
ALTER TABLE [log4Private].[Journal]
    ADD CONSTRAINT [FK_Journal_Severity] FOREIGN KEY ([SeverityId]) REFERENCES [log4Private].[Severity] ([SeverityId]);


GO
PRINT N'Creating [log4Private].[FK_Journal_SqlException]...';


GO
ALTER TABLE [log4Private].[Journal]
    ADD CONSTRAINT [FK_Journal_SqlException] FOREIGN KEY ([ExceptionId]) REFERENCES [log4Private].[SqlException] ([ExceptionId]);


GO
PRINT N'Creating [log4Private].[CK_JournalControl_OnOffSwitch]...';


GO
ALTER TABLE [log4Private].[JournalControl]
    ADD CONSTRAINT [CK_JournalControl_OnOffSwitch] CHECK ([OnOffSwitch]='OFF' OR [OnOffSwitch]='ON');


GO
PRINT N'Creating [stg].[CK_stg_Customer_IsDeleted]...';


GO
ALTER TABLE [stg].[Customer]
    ADD CONSTRAINT [CK_stg_Customer_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_Customer_CategoryIsMapped]...';


GO
ALTER TABLE [stg].[Customer]
    ADD CONSTRAINT [CK_stg_Customer_CategoryIsMapped] CHECK (CategoryIsMapped = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_BusinessUnit_IsDeleted]...';


GO
ALTER TABLE [stg].[BusinessUnit]
    ADD CONSTRAINT [CK_stg_BusinessUnit_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_OrderShippedNotInvoiced_IsDeleted]...';


GO
ALTER TABLE [stg].[OrderShippedNotInvoiced]
    ADD CONSTRAINT [CK_stg_OrderShippedNotInvoiced_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_OrderBacklog_IsDeleted]...';


GO
ALTER TABLE [stg].[OrderBacklog]
    ADD CONSTRAINT [CK_stg_OrderBacklog_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_Invoice_IsDeleted]...';


GO
ALTER TABLE [stg].[Invoice]
    ADD CONSTRAINT [CK_stg_Invoice_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_Site_IsDeleted]...';


GO
ALTER TABLE [stg].[Site]
    ADD CONSTRAINT [CK_stg_Site_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_ProductCategory_IsDeleted]...';


GO
ALTER TABLE [stg].[ProductCategory]
    ADD CONSTRAINT [CK_stg_ProductCategory_IsDeleted] CHECK (IsDeleted = 'Y' or IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_Product_IsDeleted]...';


GO
ALTER TABLE [stg].[Product]
    ADD CONSTRAINT [CK_stg_Product_IsDeleted] CHECK (IsDeleted = 'Y' OR IsDeleted = 'N');


GO
PRINT N'Creating [stg].[CK_stg_PaymentTerm_IsDeleted]...';


GO
ALTER TABLE [stg].[PaymentTerm]
    ADD CONSTRAINT [CK_stg_PaymentTerm_IsDeleted] CHECK (IsDeleted = 'Y' OR IsDeleted = 'N');


GO
PRINT N'Creating [log4].[FormatElapsedTime]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE FUNCTION [log4].[FormatElapsedTime]
(
  @StartTime                      datetime
, @EndTime                        datetime  = NULL
, @ShowMillisecsIfUnderNumSecs    tinyint   = NULL
)

RETURNS varchar(48)

AS

--<CommentHeader>
/**************************************************************************************************

Properties
==========
FUNCTION NAME:      [log4].[FormatElapsedTime]
DESCRIPTION:        Returns a string describing the time elapsed between start and end time
DATE OF ORIGIN:		16-FEB-2007
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:         Various
DEPENDENCIES:       None

Additional Notes
================
Builds a string that looks like this: "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
16-FEB-2007		GML		v0.0.2		Created
------------	------	-------		--------------------------------------------------------------
01-MAR-2015		GML		v0.0.13		Fixed bug when number of hours is greater than 99
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/
--</CommentHeader>

BEGIN
	DECLARE	  @time                     int
			, @hrs                      int
			, @mins                     int
			, @secs                     int
			, @msecs                    int
			, @Duration                 varchar(48)

	IF @StartTime IS NULL AND @EndTime IS NULL
		SET @Duration = 'Start and End Times are both NULL'
	ELSE IF @StartTime IS NULL
		SET @Duration = 'Start Time is NULL'
	ELSE
		BEGIN
			IF @EndTime IS NULL SET @EndTime = GETDATE()

			SET @time = DATEDIFF(ss, @StartTime, @EndTime)

			IF @time > ISNULL(@ShowMillisecsIfUnderNumSecs, 5)
				BEGIN
					SET @hrs        = @time / 3600
					SET @mins       = (@time % 3600) / 60
					SET @secs       = (@time % 3600) % 60
					SET @Duration   = CASE
										WHEN @hrs = 0 THEN ''
										WHEN @hrs = 1 THEN CAST(@hrs AS varchar(4)) + ' hr, '
										ELSE CAST(@hrs AS varchar(8)) + ' hrs, '
									  END
									+ CASE
										WHEN @mins = 1 THEN CAST(@mins AS varchar(4)) + ' min'
										ELSE CAST(@mins AS varchar(2)) + ' mins'
									  END
									+ ' and '
									+ CASE
										WHEN @secs = 1 THEN CAST(@secs AS varchar(2)) + ' sec'
										ELSE CAST(@secs AS varchar(2)) + ' secs'
									  END
				END
			ELSE
				BEGIN
					SET @msecs      = DATEDIFF(ms, @StartTime, @EndTime)
					SET @Duration   = CAST(@msecs AS varchar(6)) + ' milliseconds'
				END
		END

	RETURN @Duration
END
GO
PRINT N'Creating [log4].[GetJournalControl]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE FUNCTION [log4].[GetJournalControl]
(
  @ModuleName		varchar(255)
, @GroupName		varchar(255)
)

RETURNS varchar(3)

AS

--<CommentHeader>
/**************************************************************************************************

Properties
==========
FUNCTION NAME:      [log4].[GetJournalControl]
DESCRIPTION:		Returns the ON/OFF value for the specified Journal Name, or Group Name if
					Module not found or the system default if neither is found
DATE OF ORIGIN:		15-APR-2008
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:         Various
DEPENDENCIES:       None

Additional Notes
================
Builds a string that looks like this: "0 hr(s) 1 min(s) and 22 sec(s)" or "1345 milliseconds"

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
15-APR-2008		GML		v0.0.3		Created
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/
--</CommentHeader>

BEGIN
	RETURN
		(
			SELECT
				TOP 1 OnOffSwitch
			FROM
				(
						SELECT
							  OnOffSwitch
							, 1 AS [Precedence]
						FROM
							[log4Private].[JournalControl]
						WHERE
							ModuleName = 'SYSTEM_OVERRIDE'
						AND
							OnOffSwitch = 'OFF' -- only care about the override when it's OFF
					UNION
						SELECT
							  OnOffSwitch
							, 10 AS [Precedence]
						FROM
							[log4Private].[JournalControl]
						WHERE
							ModuleName = @ModuleName
					UNION
						SELECT
							  OnOffSwitch
							, 100 AS [Precedence]
						FROM
							[log4Private].[JournalControl]
						WHERE
							ModuleName = @GroupName
					UNION
						SELECT
							  OnOffSwitch
							, 200 AS [Precedence]
						FROM
							[log4Private].[JournalControl]
						WHERE
							ModuleName = 'SYSTEM_DEFAULT'
					UNION
						SELECT
							  'OFF'		AS [OnOffSwitch]
							, 300		AS [Precedence]
				) AS [x]
			ORDER BY
				[Precedence] ASC
		)
END
GO
PRINT N'Creating [privy].[GetLoadParameters]...';


GO
create function [privy].[GetLoadParameters]
(
  @ModuleName varchar(200)
)
returns table
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
FUNCTION NAME:  privy.GetLoadParameters
DESCRIPTION:    Returns the load parameters for the specified module or override if set, otherwise the default
				parameters if the module is not recognised
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    14-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

return
	(
		select top 1
			  ModuleName
			, DataCaptureStart
			, DataCaptureEnd
		from
			(
					select
						ModuleName, DataCaptureStart, DataCaptureEnd, 1 as [Precedence]
					from
						privy.StagingLoadParameter
					where
							ModuleName = 'OVERRIDE'
						--! Only use the override when the parameters are set
						and DataCaptureStart is not null
						and DataCaptureEnd is not null
				union all
					select
						ModuleName, DataCaptureStart, DataCaptureEnd, 10 as [Precedence]
					from
						privy.StagingLoadParameter
					where
						ModuleName = @ModuleName
				union all
					select
						ModuleName, DataCaptureStart, DataCaptureEnd, 100 as [Precedence]
					from
						privy.StagingLoadParameter
					where
						ModuleName = 'DEFAULT'
			) as x
		order by x.Precedence asc
	)
GO
PRINT N'Creating [etl].[InvoiceDelta]...';


GO
create view [etl].[InvoiceDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.InvoiceDelta
DESCRIPTION:    Exposes Invoice changes (new, changed and deleted) in the format best suited to populate the Interim
				Data Warehouse/Mart
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    13-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		13-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  i.InvoiceKey																				as [InvoiceKey]
		, i.IsDeleted																				as [IsDeleted]
		--! Some standard entities (N/S, N/F, N/I etc) already have the correct DataSourceKey
		, case when i.SYSTEM_ID = 100000 then i.SYSTEM_ID else i.SYSTEM_ID + 100100 end				as [DataSourceKey]
		, cast(i.REC_ID as nvarchar(50))															as [QlikViewInvoiceKey]
		, cast(1 as int)																			as [LineCount]
		, cast(convert(char(8), i.INVOICE_DATE, 112) as int)										as [InvoiceDateKey]
		, i.INVOICE_DATE																			as [InvoiceDate]
		-----------------------------------------------------------------------------------------------------------------------
		, i.INVOICE_NUMBER																			as [InvoiceNumber]
		, case when isnumeric(i.INVOICE_LINE_NUMBER) = 1
			then cast(i.INVOICE_LINE_NUMBER as int)
			else 999999
		  end																						as [InvoiceLineNumber]
		, i.INVOICE_LINE_NUMBER																		as [NativeInvoiceLineNumber]
		-----------------------------------------------------------------------------------------------------------------------
		, i.ORDER_NUMBER																			as [OrderNumber]
		, case when isnumeric(i.ORDER_LINE_NUMBER) = 1
			then cast(i.ORDER_LINE_NUMBER as int)
			else 999999
		  end																						as [OrderLineNumber]
		, i.ORDER_LINE_NUMBER																		as [NativeOrderLineNumber]
		-----------------------------------------------------------------------------------------------------------------------
		, i.INVOICE_TYPE																			as [NativeInvoiceType]
		, i.InvoiceTypeName																			as [InvoiceTypeName]
		, i.LOCAL_SITE_SOLD																			as [LocalSellingSite]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SITE_ID is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when i.SITE_ID is null then -1 else coalesce(s.SiteKey, -2) end						as [SiteKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If ITEM_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when i.ITEM_NO is null then -1 else coalesce(p.ProductKey, -2) end					as [ProductKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SOLD_TO_CUSTOMER_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when i.SOLD_TO_CUSTOMER_NO is null then -1 else coalesce(soldc.CustomerKey, -2) end	as [SoldToCustomerKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SHIP_TO_CUSTOMER_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when i.SHIP_TO_CUSTOMER_NO is null then -1 else coalesce(shipc.CustomerKey, -2) end	as [ShippedToCustomerKey]
		-----------------------------------------------------------------------------------------------------------------------
		, i.SALESPERSON_ID																			as [NativeSalesPersonId]
		, i.SALESPERSON_NAME																		as [NativeSalesPersonName]
		-----------------------------------------------------------------------------------------------------------------------
		--! If any Date is NULL, use "Not Specified at Source" (-1) for the date key
		, coalesce(cast(convert(char(8), i.DELIVERY_DATE, 112) as int), -1)							as [DeliveryDateKey]
		, i.DELIVERY_DATE																			as [DeliveryDate]
		, coalesce(cast(convert(char(8), i.EXPECTED_PAYMENT_DATE, 112) as int), -1)					as [ExpectedPaymentDateKey]
		, i.EXPECTED_PAYMENT_DATE																	as [ExpectedPaymentDate]
		, coalesce(cast(convert(char(8), i.ACTUAL_PAYMENT_DATE, 112) as int), -1)					as [ActualPaymentDateKey]
		, i.ACTUAL_PAYMENT_DATE																		as [ActualPaymentDate]
		-----------------------------------------------------------------------------------------------------------------------
		, i.LOCAL_DELIVERY_TERM																		as [LocalDeliveryTerm]
		, i.LOCAL_DELIVERY_TERM_TEXT																as [LocalDeliveryTermText]
		-----------------------------------------------------------------------------------------------------------------------
		--! If PAYMENT_TERM_ID is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when i.PAYMENT_TERM_ID is null then -1 else coalesce(pt.PaymentTermKey, -2) end		as [PaymentTermKey]
		-----------------------------------------------------------------------------------------------------------------------
		, i.LOCAL_PAYMENT_TERM																		as [LocalPaymentTerm]
		, i.LOCAL_PAYMENT_TERM_TEXT																	as [LocalPaymentTermText]
		, i.INVOICE_QUANTITY																		as [InvoiceQuantityValue]
		, i.INVOICE_UOM																				as [InvoiceQuantityUnitOfMeasure]
		, i.STATISTIC_QUANTITY																		as [StatisticQuantityValue]
		, i.STATISTIC_UOM																			as [StatisticQuantityUnitOfMeasure]
		, i.QUANTITY																				as [Quantity]
		, i.LOCAL_UOM																				as [LocalUnitOfMeasure]
		, i.LOCAL_UOM_HARMONIZED																	as [LocalUnitOfMeasureHarmonised]
		, i.LOCAL_UOM_FACTOR																		as [LocalUnitOfMeasureFactor]
		, i.INVOICE_AMOUNT																			as [InvoiceAmount]
		, i.LOCAL_AMOUNT																			as [LocalAmount]
		, i.GROUP_AMOUNT																			as [GroupAmountEUR]
		, i.INVOICE_CURRENCY																		as [InvoiceCurrency]
		, i.LOCAL_CURRENCY																			as [LocalCurrency]
		, i.LINE_DISCOUNT_AMOUNT																	as [LineDiscountAmount]
		, i.INVOICE_DISCOUNT_AMOUNT																	as [InvoiceDiscountAmount]
		, i.LINE_BONUS_AMOUNT																		as [LineBonusAmount]
		, i.BONUS_SHARE_AMOUNT																		as [BonusShareAmount]
		, i.STD_COST																				as [StandardCost]
		, i.STD_FREIGHT																				as [StandardFreight]
	from
		stg.Invoice as i
	left join stg.InvoiceControl as ic
		on ic.InvoiceKey = i.InvoiceKey
	left join stg.[Site] as s
		on s.NativeSiteKey = cast(i.SITE_ID as nvarchar(50))
	left join stg.Product as p
		on p.NativeProductKey = i.ITEM_NO
		and p.QlikViewSourceSystemId = i.SYSTEM_ID
	left join stg.Customer as soldc
		on soldc.NativeCustomerKey = i.SOLD_TO_CUSTOMER_NO
		and soldc.QlikViewSourceSystemId = i.SYSTEM_ID
	left join stg.Customer as shipc
		on shipc.NativeCustomerKey = i.SHIP_TO_CUSTOMER_NO
		and shipc.QlikViewSourceSystemId = i.SYSTEM_ID
	left join stg.PaymentTerm as pt
		on pt.NativePaymentTermKey = cast(i.PAYMENT_TERM_ID as nvarchar(50))
	where
		--! Exclude any duplicates based on SYSTEM_ID, INVOICE_NUMBER, ORDER_NUMBER, INVOICE_LINE_NUMBER and ORDER_LINE_NUMBER
			i.Uniqueifier = 1
		and
			(
					ic.InvoiceKey is null --! New Invoices (not yet added to control)
				or ic.PreviousDeltaHash <> i.EtlDeltaHash -- Existing Invoices that have been updated
				or ic.IsDeleted <> i.IsDeleted --! Invoices that have been soft-deleted or (possibly) re-activated
			)
GO
PRINT N'Creating [etl].[CustomerDelta]...';


GO
create view [etl].[CustomerDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.CustomerDelta
DESCRIPTION:    Exposes Customer changes (new, changed and deleted) in the format best suited to populate the Interim
				Data Warehouse/Mart.
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    12-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  c.CustomerKey
        , c.IsDeleted
		--! The standard products (N/S, N/F, N/I etc) already have the correct QlikViewSourceSystemId
        , case when c.QlikViewSourceSystemId = 100000 then c.QlikViewSourceSystemId else c.QlikViewSourceSystemId + 100100 end as [DataSourceKey]
        , c.NativeCustomerKey
        , c.CustomerNumber
        , c.CustomerName
        , c.CustomerAddress1
        , c.CustomerAddress2
        , c.CustomerAddress3
        , c.CustomerZipCode
        , c.CustomerCity
        , c.CustomerCountry
        , c.CustomerVatNumber
        , c.CustomerTypeId
        , c.CustomerTypeName
        , c.CustomerGroup1
        , c.CustomerGroup2
        , c.CustomerGroup3
        , c.CustomerGroup4
        , c.CustomerGroup5
        , c.CategoryIsMapped
        , c.NativeCustomerCategoryKey
        , c.CustomerCategoryBaseLevel
        , c.CustomerCategoryLevel1
        , c.CustomerCategoryLevel2
        , c.CustomerCategoryLevel3
        , c.CustomerCategoryLevel4
        , c.CustomerCategoryLevel5
        , c.CustomerCategoryLevel6
        , c.CustomerCategoryLevel7
        , c.CustomerCategoryLevel8
	from
		stg.Customer as c
	left join stg.CustomerControl as cc
		on cc.CustomerKey = c.CustomerKey
	where
			cc.CustomerKey is null --! New Customers (not yet added to control)
		or cc.PreviousDeltaHash <> c.EtlDeltaHash -- Existing Customers that have been updated
		or cc.IsDeleted <> c.IsDeleted --! Customers that have been soft-deleted or (possibly) re-activated
GO
PRINT N'Creating [etl].[BusinessUnitDelta]...';


GO
create view [etl].[BusinessUnitDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.BusinessUnitDelta
DESCRIPTION:    Exposes Business Unit changes (new, changed and deleted) in the format best suited to populate the
				Interim Data Warehouse/Mart.
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    16-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		16-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  bu.BusinessUnitKey
		, bu.IsDeleted
		, bu.NativeBusinessUnitKey
		, bu.StrategicBusinessUnitCode
		, bu.SalesCenterSbuCode
		, bu.RegionId
		, bu.RegionName
		, bu.RegionDescription
	from
		stg.BusinessUnit as bu
	left join stg.BusinessUnitControl as sc
		on sc.BusinessUnitKey = bu.BusinessUnitKey
	where
			sc.BusinessUnitKey is null --! New Business Units (not yet added to control)
		or sc.PreviousDeltaHash <> bu.EtlDeltaHash -- Existing Business Units that have been updated
		or sc.IsDeleted <> bu.IsDeleted --! Business Units that have been soft-deleted or (possibly) re-activated
GO
PRINT N'Creating [etl].[SiteDelta]...';


GO
create view [etl].[SiteDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.SiteDelta
DESCRIPTION:    Exposes Site changes (new, changed and deleted) in the format best suited to populate the Interim
				Data Warehouse/Mart.
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    30-MAY-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		30-MAY-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  s.SiteKey
		, s.IsDeleted
		, s.NativeSiteKey
		, s.SiteName
		, s.SiteDescription
		--! If StrategicBusinessUnitCode is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.BusinessUnit then use "Lookup Not Found" (-2)
		, case when coalesce(s.StrategicBusinessUnitCode, '') = '' then -1 else coalesce(bu.BusinessUnitKey, -2) end	as [BusinessUnitKey]
		, s.StrategicBusinessUnitCode
		, s.SalesCenterSbuCode
		, s.BusinessUnitName
		, s.RegionId
		, s.RegionName
		, s.RegionDescription
		--! The standard sites (N/S, N/F, N/I etc) may already have the correct QlikViewSourceSystemId
		, case when s.SourceSystemId = 100000 then s.SourceSystemId else s.SourceSystemId + 100100 end as [DataSourceKey]
		, s.SourceSystemId
		, s.SourceSystemName
	from
		stg.[Site] as s
	left join stg.SiteControl as sc
		on sc.SiteKey = s.SiteKey
	left join stg.BusinessUnit as bu
		on bu.NativeBusinessUnitKey = s.StrategicBusinessUnitCode
	where
			sc.SiteKey is null --! New Sites (not yet added to control)
		or sc.PreviousDeltaHash <> s.EtlDeltaHash -- Existing Sites that have been updated
		or sc.IsDeleted <> s.IsDeleted --! Sites that have been soft-deleted or (possibly) re-activated
GO
PRINT N'Creating [etl].[ProductDelta]...';


GO
create view [etl].[ProductDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.ProductDelta
DESCRIPTION:    Exposes Product changes (new, changed and deleted) in the format best suited to populate the Interim
				Data Warehouse/Mart.
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    30-MAY-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		30-MAY-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  p.ProductKey
        , p.IsDeleted
		--! The standard products (N/S, N/F, N/I etc) already have the correct QlikViewSourceSystemId
        , case when p.QlikViewSourceSystemId = 100000 then p.QlikViewSourceSystemId else p.QlikViewSourceSystemId + 100100 end as [DataSourceKey]
        , p.NativeProductKey
        , p.ProductNumber
        , p.ProductName
        , p.ProductTypeId
        , p.ProductTypeName
        , p.ProductGnit
        , p.ProductDescription1
        , p.ProductDescription2
        , p.LocalProductGroup1
        , p.LocalProductGroup2
        , p.LocalProductGroup3
        , p.LocalProductGroup4
        , p.LocalProductGroup5
        , p.NativeProductCategoryKey
        , p.ProductCategoryBaseLevel
		, p.ProductCategoryLevel1Id
        , p.ProductCategoryLevel1
 		, p.ProductCategoryLevel2Id
        , p.ProductCategoryLevel2
		, p.ProductCategoryLevel3Id
        , p.ProductCategoryLevel3
		, p.ProductCategoryLevel4Id
        , p.ProductCategoryLevel4
		, p.ProductCategoryLevel5Id
        , p.ProductCategoryLevel5
		, p.ProductCategoryLevel6Id
        , p.ProductCategoryLevel6
	from
		stg.Product as p
	left join stg.ProductControl as pc
		on pc.ProductKey = p.ProductKey
	where
			pc.ProductKey is null --! New Products (not yet added to control)
		or pc.PreviousDeltaHash <> p.EtlDeltaHash -- Existing Products that have been updated
		or pc.IsDeleted <> p.IsDeleted --! Products that have been soft-deleted or (possibly) re-activated
GO
PRINT N'Creating [etl].[ProductCategoryDelta]...';


GO
create view [etl].[ProductCategoryDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.ProductCategoryDelta
DESCRIPTION:    Exposes Product Category changes (new, changed and deleted) in the format best suited to populate the
				Interim Data Warehouse/Mart.
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    19-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		19-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  pc.ProductCategoryKey
		, pc.IsDeleted
		, pc.NativeProductCategoryKey
		, pc.ProductCategoryId
		, pc.ProductCategoryName
		, pc.NodeDepth
		, pc.Level3Id
		, pc.Level3Name
		, pc.Level2Id
		, pc.Level2Name
		, pc.Level1Id
		, pc.Level1Name
		, pc.ProductCategoryDescription
	from
		stg.ProductCategory as pc
	left join stg.ProductCategoryControl as pcc
		on pcc.ProductCategoryKey = pc.ProductCategoryKey
	where
			pcc.ProductCategoryKey is null --! New Product Categorys (not yet added to control)
		or pcc.PreviousDeltaHash <> pc.EtlDeltaHash -- Existing Product Categorys that have been updated
		or pcc.IsDeleted <> pc.IsDeleted --! Product Categorys that have been soft-deleted or (possibly) re-activated
GO
PRINT N'Creating [etl].[PaymentTermDelta]...';


GO
create view [etl].[PaymentTermDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.PaymentTermDelta
DESCRIPTION:    Exposes Payment Term changes (new, changed and deleted) in the format best suited to populate the Interim
				Data Warehouse/Mart.
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    12-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  p.PaymentTermKey
        , p.IsDeleted
        , p.NativePaymentTermKey
        , p.PaymentTermName
        , p.PaymentTermDays
        , p.PaymentTermDescription
	from
		stg.PaymentTerm as p
	left join stg.PaymentTermControl as pc
		on pc.PaymentTermKey = p.PaymentTermKey
	where
			pc.PaymentTermKey is null --! New Payment Terms (not yet added to control)
		or pc.PreviousDeltaHash <> p.EtlDeltaHash -- Existing Payment Terms that have been updated
		or pc.IsDeleted <> p.IsDeleted --! Payment Terms that have been soft-deleted or (possibly) re-activated
GO
PRINT N'Creating [etl].[OrderShippedNotInvoicedDelta]...';


GO
create view [etl].[OrderShippedNotInvoicedDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.OrderShippedNotInvoicedDelta
DESCRIPTION:    Exposes changes to Orders shipped-not-invoiced (new, changed and deleted) in the format best suited to
				populate the Interim Data Warehouse/Mart
				Data Warehouse/Mart
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    14-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		14-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  ord.OrderShippedNotInvoicedKey																as [OrderShippedNotInvoicedKey]
		, ord.IsDeleted																					as [IsDeleted]
		--! Some standard entities (N/S, N/F, N/I etc) already have the correct DataSourceKey
		, case when ord.SYSTEM_ID = 100000 then ord.SYSTEM_ID else ord.SYSTEM_ID + 100100 end			as [DataSourceKey]
		, cast(ord.REC_ID as nvarchar(50))																as [QlikViewOrderShippedNotInvoicedKey]
		, cast(1 as int)																				as [LineCount]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.ORDER_NUMBER																				as [OrderNumber]
		, case when isnumeric(ord.ORDER_LINE_NUMBER) = 1
			then cast(ord.ORDER_LINE_NUMBER as int)
			else 999999
		  end																							as [OrderLineNumber]
		, ord.ORDER_LINE_NUMBER																			as [NativeOrderLineNumber]
		, ord.SHIPPING_DOCUMENT																			as [NativeShippingDocumentKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If any Date is NULL, use "Not Specified at Source" (-1) for the date key
		, coalesce(cast(convert(char(8), ord.EXPECTED_INVOICE_DATE, 112) as int), -1)					as [ExpectedInvoiceDateKey]
		, ord.EXPECTED_INVOICE_DATE																		as [ExpectedInvoiceDate]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.ORDER_TYPE																				as [NativeOrderType]
		, ord.OrderTypeName																				as [OrderTypeName]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.LOCAL_SITE_SOLD																			as [LocalSellingSite]
		--! If SITE_ID is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.SITE_ID is null then -1 else coalesce(s.SiteKey, -2) end						as [SiteKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If ITEM_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.ITEM_NO is null then -1 else coalesce(p.ProductKey, -2) end						as [ProductKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SOLD_TO_CUSTOMER_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.SOLD_TO_CUSTOMER_NO is null then -1 else coalesce(soldc.CustomerKey, -2) end	as [SoldToCustomerKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SHIP_TO_CUSTOMER_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.SHIP_TO_CUSTOMER_NO is null then -1 else coalesce(shipc.CustomerKey, -2) end	as [ShippedToCustomerKey]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.SALESPERSON_ID																			as [NativeSalesPersonId]
		, ord.SALESPERSON_NAME																			as [NativeSalesPersonName]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.SHIPPED_QUANTITY																			as [ShippedQuantityValue]
		, ord.SHIPPED_UOM																				as [ShippedQuantityUnitOfMeasure]
		, ord.STATISTIC_QUANTITY																		as [StatisticQuantityValue]
		, ord.STATISTIC_UOM																				as [StatisticQuantityUnitOfMeasure]
		, ord.QUANTITY																					as [Quantity]
		, ord.LOCAL_UOM																					as [LocalUnitOfMeasure]
		, ord.LOCAL_UOM_HARMONIZED																		as [LocalUnitOfMeasureHarmonised]
		, ord.LOCAL_UOM_FACTOR																			as [LocalUnitOfMeasureFactor]
		, ord.SHIPPED_AMOUNT																			as [ShippedAmount]
		, ord.LOCAL_AMOUNT																				as [LocalAmount]
		, ord.GROUP_AMOUNT																				as [GroupAmountEUR]
		, ord.SHIPPED_CURRENCY																			as [ShippedCurrency]
		, ord.LOCAL_CURRENCY																			as [LocalCurrency]
		, ord.LINE_DISCOUNT_AMOUNT																		as [LineDiscountAmount]
		, ord.ORDER_DISCOUNT_AMOUNT																		as [OrderDiscountAmount]
		, ord.LINE_BONUS_AMOUNT																			as [LineBonusAmount]
		, ord.BONUS_SHARE_AMOUNT																		as [BonusShareAmount]
	from
		stg.OrderShippedNotInvoiced as ord
	left join stg.OrderShippedNotInvoicedControl as ctrl
		on ctrl.OrderShippedNotInvoicedKey = ord.OrderShippedNotInvoicedKey
	left join stg.[Site] as s
		on s.NativeSiteKey = cast(ord.SITE_ID as nvarchar(50))
	left join stg.Product as p
		on p.NativeProductKey = ord.ITEM_NO
		and p.QlikViewSourceSystemId = ord.SYSTEM_ID
	left join stg.Customer as soldc
		on soldc.NativeCustomerKey = ord.SOLD_TO_CUSTOMER_NO
		and soldc.QlikViewSourceSystemId = ord.SYSTEM_ID
	left join stg.Customer as shipc
		on shipc.NativeCustomerKey = ord.SHIP_TO_CUSTOMER_NO
		and shipc.QlikViewSourceSystemId = ord.SYSTEM_ID
	where
		--! Exclude any duplicates based on SYSTEM_ID, ORDER_NUMBER and ORDER_LINE_NUMBER
			ord.Uniqueifier = 1
		and
			(
					ctrl.OrderShippedNotInvoicedKey is null --! New Orders (not yet added to control)
				or ctrl.PreviousDeltaHash <> ord.EtlDeltaHash -- Existing Orders that have been updated
				or ctrl.IsDeleted <> ord.IsDeleted --! Orders that have been soft-deleted or (possibly) re-activated
			)
GO
PRINT N'Creating [etl].[OrderBacklogDelta]...';


GO
create view [etl].[OrderBacklogDelta]
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
VIEW NAME:      etl.OrderBacklogDelta
DESCRIPTION:    Exposes changes to Orders shipped-not-invoiced (new, changed and deleted) in the format best suited to
				populate the Interim Data Warehouse/Mart
				Data Warehouse/Mart
AUTHOR:         Greg M. Lucas
ORIGIN DATE:    15-JUN-2017

Additional Notes
================


REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		15-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------


**********************************************************************************************************************/
--</CommentHeader>

	select
		  ord.OrderBacklogKey																			as [OrderBacklogKey]
		, ord.IsDeleted																					as [IsDeleted]
		--! Some standard entities (N/S, N/F, N/I etc) already have the correct DataSourceKey
		, case when ord.SYSTEM_ID = 100000 then ord.SYSTEM_ID else ord.SYSTEM_ID + 100100 end			as [DataSourceKey]
		, cast(ord.REC_ID as nvarchar(50))																as [QlikViewOrderBacklogKey]
		, cast(1 as int)																				as [LineCount]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.ORDER_NUMBER																				as [OrderNumber]
		, case when isnumeric(ord.ORDER_LINE_NUMBER) = 1
			then cast(ord.ORDER_LINE_NUMBER as int)
			else 999999
		  end																							as [OrderLineNumber]
		, ord.ORDER_LINE_NUMBER																			as [NativeOrderLineNumber]
		-----------------------------------------------------------------------------------------------------------------------
		--! If any Date is NULL, use "Not Specified at Source" (-1) for the date key
		, coalesce(cast(convert(char(8), ord.EXPECTED_INVOICE_DATE, 112) as int), -1)					as [ExpectedInvoiceDateKey]
		, ord.EXPECTED_INVOICE_DATE																		as [ExpectedInvoiceDate]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.ORDER_TYPE																				as [NativeOrderType]
		, ord.OrderTypeName																				as [OrderTypeName]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.LOCAL_SITE_SOLD																			as [LocalSellingSite]
		--! If SITE_ID is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.SITE_ID is null then -1 else coalesce(s.SiteKey, -2) end						as [SiteKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If ITEM_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.ITEM_NO is null then -1 else coalesce(p.ProductKey, -2) end						as [ProductKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SOLD_TO_CUSTOMER_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.SOLD_TO_CUSTOMER_NO is null then -1 else coalesce(soldc.CustomerKey, -2) end	as [SoldToCustomerKey]
		-----------------------------------------------------------------------------------------------------------------------
		--! If SHIP_TO_CUSTOMER_NO is NULL, use "Not Specified at Source" (-1) and if there
		--! is no match in stg.Site then use "Lookup Not Found" (-2)
		, case when ord.SHIP_TO_CUSTOMER_NO is null then -1 else coalesce(shipc.CustomerKey, -2) end	as [ShippedToCustomerKey]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.SALESPERSON_ID																			as [NativeSalesPersonId]
		, ord.SALESPERSON_NAME																			as [NativeSalesPersonName]
		-----------------------------------------------------------------------------------------------------------------------
		, ord.ORDER_QUANTITY																			as [OrderQuantityValue]
		, ord.ORDER_UOM																					as [OrderQuantityUnitOfMeasure]
		, ord.STATISTIC_QUANTITY																		as [StatisticQuantityValue]
		, ord.STATISTIC_UOM																				as [StatisticQuantityUnitOfMeasure]
		, ord.QUANTITY																					as [Quantity]
		, ord.LOCAL_UOM																					as [LocalUnitOfMeasure]
		, ord.LOCAL_UOM_HARMONIZED																		as [LocalUnitOfMeasureHarmonised]
		, ord.LOCAL_UOM_FACTOR																			as [LocalUnitOfMeasureFactor]
		, ord.ORDER_AMOUNT																				as [OrderAmount]
		, ord.LOCAL_AMOUNT																				as [LocalAmount]
		, ord.GROUP_AMOUNT																				as [GroupAmountEUR]
		, ord.ORDER_CURRENCY																			as [OrderCurrency]
		, ord.LOCAL_CURRENCY																			as [LocalCurrency]
		, ord.LINE_DISCOUNT_AMOUNT																		as [LineDiscountAmount]
		, ord.ORDER_DISCOUNT_AMOUNT																		as [OrderDiscountAmount]
		, ord.LINE_BONUS_AMOUNT																			as [LineBonusAmount]
		, ord.BONUS_SHARE_AMOUNT																		as [BonusShareAmount]
	from
		stg.OrderBacklog as ord
	left join stg.OrderBacklogControl as ctrl
		on ctrl.OrderBacklogKey = ord.OrderBacklogKey
	left join stg.[Site] as s
		on s.NativeSiteKey = cast(ord.SITE_ID as nvarchar(50))
	left join stg.Product as p
		on p.NativeProductKey = ord.ITEM_NO
		and p.QlikViewSourceSystemId = ord.SYSTEM_ID
	left join stg.Customer as soldc
		on soldc.NativeCustomerKey = ord.SOLD_TO_CUSTOMER_NO
		and soldc.QlikViewSourceSystemId = ord.SYSTEM_ID
	left join stg.Customer as shipc
		on shipc.NativeCustomerKey = ord.SHIP_TO_CUSTOMER_NO
		and shipc.QlikViewSourceSystemId = ord.SYSTEM_ID
	where
		--! Exclude any duplicates based on SYSTEM_ID, ORDER_NUMBER and ORDER_LINE_NUMBER
			ord.Uniqueifier = 1
		and
			(
					ctrl.OrderBacklogKey is null --! New Orders (not yet added to control)
				or ctrl.PreviousDeltaHash <> ord.EtlDeltaHash -- Existing Orders that have been updated
				or ctrl.IsDeleted <> ord.IsDeleted --! Orders that have been soft-deleted or (possibly) re-activated
			)
GO
PRINT N'Creating [dbo].[V_SA_INVOICE_DEMO]...';


GO





CREATE view [dbo].[V_SA_INVOICE_DEMO] as 
select inv.SYSTEM_ID, 
       inv.INVOICE_DATE, 
       inv.INVOICE_NUMBER, 
       inv.INVOICE_LINE_NUMBER, 
       inv.SHIP_TO,
	   inv.SOLD_TO,
       inv.SITE_SOLD, 
       ssite.SITE_ID,
       inv.INVOICE_TYPE, 
       inv.ITEM_NO as ITEM_NO,
	   inv.INVOICE_AMOUNT, 
       inv.INVOICE_CURRENCY, 
       inv.GROUP_AMOUNT, 
       inv.LOCAL_AMOUNT, 
       inv.LOCAL_CURRENCY, 
	   inv.LINE_DISCOUNT_AMOUNT,
	   inv.INVOICE_DISCOUNT_AMOUNT,
	   inv.LINE_BONUS_AMOUNT,
	   inv.BONUS_SHARE_AMOUNT,
	   inv.STD_COST,
	   inv.STD_FREIGHT,
	   inv.STATISTIC_QUANTITY,
	   inv.STATISTIC_UOM,
	   inv.INVOICE_QUANTITY,
	   inv.INVOICE_UOM,
	   inv.QUANTITY,
	   inv.UOM,
       isnull(cpay.PAYMENTTERM_ID, fxup.TEKST) as PAYMENTTERM_ID,
       inv.PAYMENT_TERM                        as LOCAL_PAYMENTTERM,
       inv.PAYMENT_TERM_TEXT                   as LOCAL_PAYMENTTERMTEXT,
	   inv.SALESPERSON_ID,
	   inv.SALESPERSON_NAME,
	   isnull(lic.ITEM_CATEGORY_ID, fxi.TEKST) as ITEM_CATEGORY_ID,
	   sbu.SBU,
	   lec.ENV_CATEGORY_ID
from [$(Icopal_profBIS)].dbo.SA_INVOICE as inv with (nolock)
       left outer join
         [$(Icopal_profBIS)].dbo.PU_LINK_PAYMENTTERM as cpay with (nolock)
                                     on (cpay.SYSTEM_ID     = inv.SYSTEM_ID and
                                         cpay.PAYMENT_TERM  = inv.PAYMENT_TERM)
       join
         [$(Icopal_profBIS)].dbo.PU_LINK_SITE as ssite with (nolock) on (ssite.SYSTEM_ID  = inv.SYSTEM_ID and
                                   ssite.LOCAL_SITE = inv.SITE_SOLD)
       join
         [$(Icopal_profBIS)].dbo.MD_SITE as msite with (nolock) on (msite.SITE_ID = ssite.SITE_ID)
       join
         [$(Icopal_profBIS)].dbo.MD_SBU as sbu with (nolock)on (sbu.SBU   = msite.SBU and
                           sbu.SABIS = 'Y')
       join
         [$(Icopal_profBIS)].dbo.FLEXPARAMS as fxup with (nolock) on (fxup.PARAMTYPE = 'DWH' and 
                                fxup.PARAMNAVN = 'PAYMENT_UNMAPPED')
       left outer join
         [$(Icopal_profBIS)].dbo.FLEXPARAMS as fxne with (nolock) on (fxne.PARAMTYPE = 'DWH' and 
                                fxne.PARAMNAVN = 'SALES_NOT_QLIKVIEW')
       left outer join
         [$(Icopal_profBIS)].dbo.FLEXPARAMS as fxnc with (nolock) on (fxnc.PARAMTYPE = 'DWH' and 
                                fxnc.PARAMNAVN = 'CUSTOMER_NOT_EXPORTED')
	   left outer join
	     [$(Icopal_profBIS)].dbo.FLEXPARAMS as fxi with (nolock) on (fxi.PARAMTYPE = 'DWH' and
	                           fxi.PARAMNAVN = 'SA_UNMAPPED_ITEM')	   
	   left outer join
         [$(Icopal_profBIS)].dbo.PU_LINK_UOM as plu with (nolock) on (plu.SYSTEM_ID = inv.SYSTEM_ID and
                                plu.LOCAL_UOM = inv.UOM)
	   left outer join
	     [$(Icopal_profBIS)].dbo.SA_LINK_ITEM as lic with (nolock) on (lic.SYSTEM_ID = inv.SYSTEM_ID and
		                         lic.ITEM_NO   = inv.ITEM_NO)
	   left outer join
	     [$(Icopal_profBIS)].dbo.SA_LINK_ENV as lec with (nolock) on (lec.SYSTEM_ID = inv.SYSTEM_ID and
		                        lec.ITEM_NO   = inv.ITEM_NO)
	   left outer join
	     [$(Icopal_profBIS)].dbo.SA_LINK_CUSTOMER as lis with (nolock) on (lis.SYSTEM_ID   = inv.SYSTEM_ID and
		                             lis.CUSTOMER_NO = inv.SHIP_TO)
	   
where inv.INVOICE_TYPE in (1, 2, 9) and
      isnull(lic.ITEM_CATEGORY_ID, -1)     <> isnull(fxne.TEKST, -2) and      
      isnull(lis.CUSTOMER_CATEGORY_ID, -1) <> isnull(fxnc.TEKST, -2) and      
      inv.INVOICE_DATE >= (select TEKST
                           from [$(Icopal_profBIS)].dbo.FLEXPARAMS with (nolock)
                            where PARAMTYPE = 'DWH' and
                                  PARAMNAVN = 'DATA_START_DATE')
GO
PRINT N'Creating [log4Private].[SessionInfoOutput]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4Private].[SessionInfoOutput]
(
  @SessionId          int
, @HostName           nvarchar( 128 ) = null  out
, @ProgramName        nvarchar( 128 ) = null  out
, @NTDomain           nvarchar( 128 ) = null  out
, @NTUsername         nvarchar( 128 ) = null  out
, @LoginName          nvarchar( 128 ) = null  out
, @OriginalLoginName  nvarchar( 128 ) = null  out
, @SessionLoginTime   datetime        = null  out
)

as

--<CommentHeader>
/**********************************************************************************************************************

Properties
=====================================================================================================================
PROCEDURE NAME:  SessionInfoOutput
DESCRIPTION:     Outputs session info from master.sys.dm_exec_sessions for the current @@SPID
DATE OF ORIGIN:  15-APR-2008
ORIGINAL AUTHOR: Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:      13-MAR-2012
BUILD VERSION:   0.0.11
DEPENDANTS:      log4.ExceptionHandler
                 log4.JournalWriter
DEPENDENCIES:    Called functions

Returns
=====================================================================================================================
@@ERROR - always zero on success

Additional Notes
=====================================================================================================================


Revision history
=====================================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		=================================================================================
15-APR-2008		GML		vX.Y.z		Created
------------	------	-------		---------------------------------------------------------------------------------
17-OCT-2015		GML		vX.Y.z		Now works on SQL Azure DB
------------	------	-------		---------------------------------------------------------------------------------

=====================================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**********************************************************************************************************************/
--</CommentHeader>

begin
	SET NOCOUNT ON

	begin try
	if left(@@version, 19) = 'Microsoft SQL Azure'
		begin
			set @HostName			= 'N/S in Azure'
			set @ProgramName		= 'N/S in Azure'
			set @NTDomain			= 'N/S in Azure'
			set @NTUsername			= 'N/S in Azure'
			set @LoginName			= 'N/S in Azure'
			set @OriginalLoginName	= 'N/S in Azure'
			set @SessionLoginTime	= 'N/S in Azure'
		end
	else
		begin
			select
				  @HostName				= 'N/A in Azure' --s.[host_name]
				, @ProgramName			= 'N/A in Azure' --s.[program_name]
				, @NTDomain				= 'N/A in Azure' --s.nt_domain
				, @NTUsername			= 'N/A in Azure' --s.nt_user_name
				, @LoginName			= 'N/A in Azure' --s.login_name
				, @OriginalLoginName	= 'N/A in Azure' --s.original_login_name
				, @SessionLoginTime		= '19000101 00:00:00' --s.login_time
			--from
			--	master.sys.dm_exec_sessions as [s] with (nolock)
			--where
			--	s.session_id = @SessionId
		end
	end try
	begin catch
		--! Make sure we return non-null values
		set @SessionId			= 0
		set @HostName			= ''
		set @ProgramName		= 'log4.SessionInfoOutput Error!'
		set @NTDomain			= ''
		set @NTUsername			= ''
		set @LoginName			= 'log4.SessionInfoOutput Error!'
		set @OriginalLoginName	= ''

		declare @context nvarchar(512); set @context = 'log4.SessionInfoOutput failed to retrieve session info';

		--! Only rollback if we have an uncommitable transaction
		if (xact_state() = -1)
		or (@@trancount > 0 and xact_state() != 1)
			begin
				rollback tran;
				set @context = @context + ' (Forced rolled back of all changes due to uncommitable transaction)';
			end

		--! Log this error directly
		--! Don't call ExceptionHandler in case we get another
		--! SessionInfoOutput error and and up in a never-ending loop)
		insert [log4Private].[SqlException]
		(
		  [ErrorContext]
		, [ErrorNumber]
		, [ErrorSeverity]
		, [ErrorState]
		, [ErrorProcedure]
		, [ErrorLine]
		, [ErrorMessage]
		, [ErrorDatabase]
		, [SessionIdent]
		, [ServerName]
		)
		select
			  @context
			, error_number()
			, error_severity()
			, error_state()
			, error_procedure()
			, error_line()
			, error_message()
			, db_name()
			, @@spid
			, @@servername
	end catch

	set nocount off
end
GO
PRINT N'Creating [log4Utils].[PrintString]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4Utils].[PrintString]
(
  @InputString		nvarchar(max)	= NULL
, @MaxPrintLength	int				= 4000
)

AS

--<CommentHeader>
/**********************************************************************************************************************

Properties
=====================================================================================================================
PROCEDURE NAME:		[log4Utils].[PrintString]
DESCRIPTION:		Prints the supplied string respecting all line feeds and/or carriage returns except where no
					line feeds are found, in which case the output is printed in user-specified lengths
DATE OF ORIGIN:		05-NOV-2011
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@InputString - optional, the string to print
@MaxPrintLength - Max length of string to print before inserting an unnatural break

Outputs
=======
None

Returns
=======
NULL

Additional Notes
================

Revision history
=====================================================================================================================
ChangeDate    Author   Version  Narrative
============  =======  =======  =====================================================================================
05-NOV-2011   GML      v0.0.8   Created
------------  -------  -------  -------------------------------------------------------------------------------------
13-MAR-2012   GML      v0.0.10  Fixed backwards-compatability issue with @LineFeedPos
------------  -------  -------  -------------------------------------------------------------------------------------


=====================================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**********************************************************************************************************************/
--</CommentHeader>

BEGIN
	SET NOCOUNT ON

	--! CONSTANTS (keep it SQL2005 compatible)
	DECLARE @LF					char(1); SET @LF			= CHAR(10);
	DECLARE @CR					char(1); SET @CR			= CHAR(13);
	DECLARE @CRLF				char(2); SET @CRLF		= CHAR(13) + CHAR(10);
	DECLARE @LINE_BREAK			char(3); SET @LINE_BREAK	= '%' + @LF + '%';

	--! Working Values
	DECLARE @WorkingLength		bigint
	DECLARE @WorkingString		nvarchar(max)
	DECLARE @SubString			nvarchar(max)
	DECLARE @SubStringLength	bigint

	--! Validate/correct inputs
	SET @MaxPrintLength = COALESCE(NULLIF(@MaxPrintLength, 0), 4000)

	IF @MaxPrintLength > 4000
		BEGIN
			RAISERROR('The @MaxPrintLength value of %i is greater than the maximum length supported by PRINT for unicode strings (4000)', 17, 1, @MaxPrintLength);
			RETURN(60000);
		END

	IF @MaxPrintLength < 1
		BEGIN
			RAISERROR('The @MaxPrintLength must be greater than or equal to 1 but is %i', 17, 2, @MaxPrintLength);
			RETURN(60000);
		END

	--! Working variables
	DECLARE @InputLength bigint; SET @InputLength = LEN(@InputString);

	IF @InputLength = 0
		GOTO OnComplete;

	--!
	--! Our input string may contain either carriage returns, line feeds or both
	--! to separate printing lines so we need to standardise on one of these (LF)
	--!
	SET @WorkingString = REPLACE(REPLACE(@InputString, @CRLF, @LF), @CR, @LF);

	--!
	--! If there are line feeds we use those to break down the text
	--! into individual printed lines, otherwise we print it in
	--! bite-size chunks suitable for consumption by PRINT
	--!
	IF PATINDEX(@LINE_BREAK, @InputString) > 0

		BEGIN --[BREAK_BY_LINE_FEED]

			--! Add a line feed on the end so the final iteration works as expected
			SET @WorkingString	= @WorkingString + @LF;
			SET @WorkingLength	= LEN(@WorkingString);

			DECLARE @LineFeedPos bigint; SET @LineFeedPos = 0;

			WHILE @WorkingLength > 0
				BEGIN
					--!
					--! Get the position of the next line feed
					--!
					SET @LineFeedPos = PATINDEX(@LINE_BREAK, @WorkingString);

					IF @LineFeedPos > 0
						BEGIN
							SET @SubString			= SUBSTRING(@WorkingString, 1, @LineFeedPos - 1);
							SET @SubStringLength	= LEN(@SubString);

							--!
							--! If this string is too long for a single PRINT, we pass it back
							--! to PrintString which will process the string in suitably sized chunks
							--!
							IF LEN(@SubString) > @MaxPrintLength
								EXEC [log4Utils].[PrintString] @InputString = @SubString
							ELSE
								PRINT @SubString;

							--! Remove the text we've just processed
							SET @WorkingLength	= @WorkingLength - @LineFeedPos;
							SET @WorkingString	= SUBSTRING(@WorkingString, @LineFeedPos + 1, @WorkingLength);
						END
				END

		END --[BREAK_BY_LINE_FEED]
	ELSE
		BEGIN --[BREAK_BY_LENGTH]
			--!
			--! If there are no line feeds we may have to break it down
			--! into smaller bit size chunks suitable for PRINT
			--!
			IF @InputLength > @MaxPrintLength
				BEGIN
					SET @WorkingString		= @InputString;
					SET @WorkingLength		= LEN(@WorkingString);
					SET @SubStringLength	= @MaxPrintLength;

					WHILE @WorkingLength > 0
						BEGIN
							SET @SubString			= SUBSTRING(@WorkingString, 1, @SubStringLength);
							SET @SubStringLength	= LEN(@SubString)

							--!
							--! If we still have text to process, set working values
							--!
							IF (@WorkingLength - @SubStringLength + 1) > 0
								BEGIN
									PRINT @SubString;
									--! Remove the text we've just processed
									SET @WorkingString	= SUBSTRING(@WorkingString, @SubStringLength + 1, @WorkingLength);
									SET @WorkingLength	= LEN(@WorkingString);
								END
						END
				END
			ELSE
				PRINT @InputString;

		END --[BREAK_BY_LENGTH]

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN

END
GO
PRINT N'Creating [log4Utils].[JournalReader]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4Utils].[JournalReader]
(
  @StartDate			datetime		= NULL
, @EndDate				datetime		= NULL
, @TimeZoneOffset		smallint		= NULL
, @FunctionName			varchar(256)	= NULL
, @FunctionSearchType	tinyint			= NULL
, @MessageText			varchar(512)	= NULL
, @MessageSearchType	tinyint			= NULL
, @Task					varchar(128)	= NULL
, @SeverityBitMask		smallint		= 8191 -- 8191 All Severities or 7167 to exclude debug
, @ResultSetSize		int				= NULL
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4Utils].[JournalReader]
DESCRIPTION:		Returns all Journal entries matching the specified search criteria
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@DatabaseName
@FunctionName
@MessageText
@StepInFunction
@ExtraInfo
@Severity

Outputs
=======
None

Returns
=======
@@ERROR - always zero on success

Additional Notes
================
Severity Bits (for bitmask):

   1 -- Showstopper/Critical Failure
   2 -- Severe Failure
   4 -- Major Failure
   8 -- Moderate Failure
  16 -- Minor Failure
  32 -- Concurrency Violation
  64 -- Reserved for future Use
 128 -- Reserved for future Use
 256 -- Informational
 512 -- Success
1024 -- Debug
2048 -- Reserved for future Use
4096 -- Reserved for future Use

Function and Message Search Types:

0 = Exclude from Search
1 = Begins With
2 = Ends With
3 = Contains
4 = Exact Match

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		--------------------------------------------------------------
03-MAY-2011		GML		v0.0.4		Removed ExtraInfo from result set for performance
									Added @TimeZoneOffset for ease of use in other timezones
------------	------	-------		--------------------------------------------------------------
28-AUG-2011		GML		v0.0.6		Added support for ExceptionId and Task columns
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET NOCOUNT ON

	--! Working variables
	DECLARE	  @Error            int
			, @RowCount         int

	SET @Error 			= 0
	SET @TimeZoneOffset	= COALESCE(@TimeZoneOffset, 0)
	SET @Task			= COALESCE(@Task, '')

	--!
	--! Format the Function search string according to the required search criteria
	--!
	IF LEN(ISNULL(@FunctionName, '')) = 0 OR @FunctionSearchType = 0
		SET @FunctionName = '%'
	ELSE IF LEN(@FunctionName) < 256
		BEGIN
			IF @FunctionSearchType & 1 = 1 AND SUBSTRING(REVERSE(@FunctionName), 1, 1) != '%'
				SET @FunctionName = @FunctionName + '%'

			IF @FunctionSearchType & 2 = 2 AND SUBSTRING(@FunctionName, 1, 1) != '%'
				SET @FunctionName = '%' + @FunctionName

			--! If @FunctionSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! Format the Message search string according to the required search criteria
	--!
	IF LEN(ISNULL(@MessageText, '')) = 0 OR @MessageSearchType = 0
		SET @MessageText = '%'
	ELSE IF LEN(@MessageText) < 512
		BEGIN
			IF @MessageSearchType & 1 = 1 AND SUBSTRING(REVERSE(@MessageText), 1, 1) != '%'
				SET @MessageText = @MessageText + '%'

			IF @MessageSearchType & 2 = 2 AND SUBSTRING(@MessageText, 1, 1) != '%'
				SET @MessageText = '%' + @MessageText

			--! If @MessageSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! If @ResultSetSize is invalid, just return the last 100 rows
	--!
	IF ISNULL(@ResultSetSize, -1) < 1 SET @ResultSetSize = 100
	IF @StartDate IS NULL SET @StartDate = CONVERT(datetime, CONVERT(char(8), DATEADD(day, -7, GETDATE())) + ' 00:00:00', 112)
	IF @EndDate IS NULL SET @EndDate = CONVERT(datetime, CONVERT(char(8), GETDATE(), 112) + ' 23:59:59', 112)

	--! Reverse any time zone offset so we are searching on system time
	SET @StartDate	= DATEADD(hour, @TimeZoneOffset * -1, @StartDate)
	SET @EndDate	= DATEADD(hour, @TimeZoneOffset * -1, @EndDate)

	--!
	--! Return the required results
	--!
	SELECT TOP (@ResultSetSize)
		  j.JournalId
		, DATEADD(hour, @TimeZoneOffset, j.SystemDate)	AS [LocalTime]
		---------------------------------------------------------------------------------------------------
		, j.Task										AS [TaskOrJobName]
		, j.FunctionName								AS [FunctionName]
		, j.StepInFunction								AS [StepInFunction]
		, j.MessageText									AS [MessageText]
		, s.SeverityName								AS [Severity]
		, j.ExceptionId									AS [ExceptionId]
		---------------------------------------------------------------------------------------------------
		, j.SystemDate
	FROM
		[log4Private].[Journal] AS [j]
	INNER JOIN
		[log4Private].[Severity] AS [s]
	ON
		s.SeverityId = j.SeverityId
	WHERE
		j.SystemDate BETWEEN @StartDate AND @EndDate
	AND
		j.SeverityId & @SeverityBitMask = j.SeverityId
	AND
		j.Task = COALESCE(NULLIF(@Task, ''), j.Task)
	AND
		j.FunctionName LIKE @FunctionName
	AND
		j.MessageText LIKE @MessageText
	ORDER BY
		j.JournalId DESC

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN(@Error)

END
GO
PRINT N'Creating [log4Utils].[JournalPrinter]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4Utils].[JournalPrinter]
(
  @JournalId		int
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4Utils].[JournalPrinter]
DESCRIPTION:		Prints the contents of JournalDetail for the specified Journal ID respecting all
					line feeds and/or carriage returns
DATE OF ORIGIN:		03-MAY-2011
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@JournalId - if -1, just processes any provided input string
@InputString - optional, the string to print

Outputs
=======
None

Returns
=======
NULL

Additional Notes
================

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
03-MAY-2011		GML		v0.0.4		Created
------------	------	-------		--------------------------------------------------------------
05-NOV-2011		GML		v0.0.8		Now calls log4.PrintString (which is SQL2005 compatible)
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET NOCOUNT ON;

	--! Working Values
	DECLARE @WorkingString		varchar(max)

	SELECT @WorkingString = ExtraInfo FROM [log4Private].[JournalDetail] WHERE JournalId = @JournalId

	IF COALESCE(@WorkingString, '') = ''
		BEGIN
			RAISERROR('No Extra Info for Journal ID: %d!', 0, 1, @JournalId);
		END
	ELSE
		BEGIN
			PRINT '';
			PRINT REPLICATE('=', 120);

			EXEC [log4Utils].[PrintString] @WorkingString

			PRINT '';
			PRINT REPLICATE('=', 120);
			RAISERROR('Completed processing journal detail for Journal ID: %d', 0, 1, @JournalId) WITH NOWAIT;
		END

	SET NOCOUNT OFF;

	RETURN;
END
GO
PRINT N'Creating [log4Utils].[ExceptionReader]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4Utils].[ExceptionReader]
(
  @StartDate			datetime		= NULL
, @EndDate				datetime		= NULL
, @TimeZoneOffset		smallint		= NULL
, @ErrorProcedure		varchar(256)	= NULL
, @ProcedureSearchType	tinyint			= NULL
, @ErrorMessage			varchar(512)	= NULL
, @MessageSearchType	tinyint			= NULL
, @ResultSetSize		int				= NULL
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4Utils].[ExceptionReader]
DESCRIPTION:		Returns all Exceptions matching the specified search criteria
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			29-AUG-2011
BUILD VERSION:		0.0.6
DEPENDANTS:			None
DEPENDENCIES:		None

Returns
=======
@@ERROR - always zero on success

Additional Notes
================

Function and Message Search Types:

0 = Exclude from Search
1 = Begins With
2 = Ends With
3 = Contains
4 = Exact Match

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		--------------------------------------------------------------
03-MAY-2011		GML		v0.0.4		Added @TimeZoneOffset for ease of use in other timezones
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
	SET NOCOUNT ON;

	--! Working variables
	DECLARE	  @Error            int
			, @RowCount         int

	SET @Error 			= 0
	SET @TimeZoneOffset	= COALESCE(@TimeZoneOffset, 0)

	--!
	--! Format the Function search string according to the required search criteria
	--!
	IF LEN(ISNULL(@ErrorProcedure, '')) = 0 OR @ProcedureSearchType = 0
		SET @ErrorProcedure = '%'
	ELSE IF LEN(@ErrorProcedure) < 256
		BEGIN
			IF @ProcedureSearchType & 1 = 1 AND SUBSTRING(REVERSE(@ErrorProcedure), 1, 1) != '%'
				SET @ErrorProcedure = @ErrorProcedure + '%'

			IF @ProcedureSearchType & 2 = 2 AND SUBSTRING(@ErrorProcedure, 1, 1) != '%'
				SET @ErrorProcedure = '%' + @ErrorProcedure

			--! If @ProcedureSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! Format the Message search string according to the required search criteria
	--!
	IF LEN(ISNULL(@ErrorMessage, '')) = 0 OR @MessageSearchType = 0
		SET @ErrorMessage = '%'
	ELSE IF LEN(@ErrorMessage) < 512
		BEGIN
			IF @MessageSearchType & 1 = 1 AND SUBSTRING(REVERSE(@ErrorMessage), 1, 1) != '%'
				SET @ErrorMessage = @ErrorMessage + '%'

			IF @MessageSearchType & 2 = 2 AND SUBSTRING(@ErrorMessage, 1, 1) != '%'
				SET @ErrorMessage = '%' + @ErrorMessage

			--! If @MessageSearchType = 4, do nothing as we want an exact match
		END

	--!
	--! If @ResultSetSize is invalid, just return the last 100 rows
	--!
	IF ISNULL(@ResultSetSize, -1) < 1 SET @ResultSetSize = 100
	IF @StartDate IS NULL SET @StartDate = CONVERT(datetime, CONVERT(char(8), DATEADD(day, -10, GETDATE())) + ' 00:00:00', 112)
	IF @EndDate IS NULL SET @EndDate = CONVERT(datetime, CONVERT(char(8), GETDATE(), 112) + ' 23:59:59', 112)

	--! Reverse any time zone offset so we are searching on system time
	SET @StartDate	= DATEADD(hour, @TimeZoneOffset * -1, @StartDate)
	SET @EndDate	= DATEADD(hour, @TimeZoneOffset * -1, @EndDate)

	--!
	--! Return the required results
	--!
	SELECT TOP (@ResultSetSize)
		  ExceptionId
		, DATEADD(hour, @TimeZoneOffset, SystemDate)						AS [LocalTime]
		---------------------------------------------------------------------------------------------------
		, ErrorNumber
		, ErrorContext
		, REPLACE(REPLACE(ErrorMessage, CHAR(13), '  '), CHAR(10), '  ')	AS [ErrorMessage]
		, ErrorSeverity
		, ErrorState
		, ErrorProcedure
		, ErrorLine
		, ErrorDatabase
		---------------------------------------------------------------------------------------------------
		, SystemDate
		, SessionIdent
		, [ProgramName]
		, [NTDomain]
		, [NTUsername]
		, [LoginName]
	FROM
		[log4Private].[SqlException]
	WHERE
		SystemDate BETWEEN @StartDate AND @EndDate
	AND
		ErrorProcedure LIKE @ErrorProcedure
	AND
		ErrorMessage LIKE @ErrorMessage
	ORDER BY
		ExceptionId DESC

	SELECT @Error = @@ERROR, @RowCount = @@ROWCOUNT

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN(@Error)

END
GO
PRINT N'Creating [log4].[ExceptionHandler]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE   PROCEDURE [log4].[ExceptionHandler]
(
  @ErrorContext		nvarchar(512)	= NULL
, @ErrorProcedure	nvarchar(128)	= NULL	OUT
, @ErrorNumber		int				= NULL	OUT
, @ErrorSeverity	int				= NULL	OUT
, @ErrorState		int				= NULL	OUT
, @ErrorLine		int				= NULL	OUT
, @ErrorMessage		nvarchar(4000)	= NULL	OUT
, @ReturnMessage	nvarchar(1000)	= NULL	OUT
, @ExceptionId		int				= NULL	OUT
)
AS

--<CommentHeader>
/**********************************************************************************************************************

Properties
=====================================================================================================================
PROCEDURE NAME:		log4.ExceptionHandler
DESCRIPTION:		Returns error info as output parameters and writes info to Exception table
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:			Various
DEPENDENCIES:		log4.SessionInfoOutput

Outputs
=====================================================================================================================
Outputs all values collected within the CATCH block plus a formatted error message built from context and error msg

Returns
=====================================================================================================================
- @@ERROR - always zero on success


Additional Notes
=====================================================================================================================
-

Revision history
=====================================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		=================================================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		---------------------------------------------------------------------------------
15-APR-2008		GML		v0.0.3		Now utilises SessionInfoOutput sproc for session values
------------	------	-------		---------------------------------------------------------------------------------

=====================================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**********************************************************************************************************************/
--</CommentHeader>

BEGIN
	SET NOCOUNT ON;

	DECLARE @ErrorDatabase nvarchar(128) = DB_NAME();

	SET @ErrorContext	= COALESCE(@ErrorContext, '');
	SET @ErrorProcedure	= COALESCE(NULLIF(@ErrorProcedure, ''), ERROR_PROCEDURE(), '');
	SET @ErrorNumber		= COALESCE(ERROR_NUMBER(), 0);
	SET @ErrorSeverity	= COALESCE(ERROR_SEVERITY(), 0);
	SET @ErrorState		= COALESCE(ERROR_STATE(), 0);
	SET @ErrorLine		= COALESCE(ERROR_LINE(), 0);
	SET @ErrorMessage	= COALESCE(ERROR_MESSAGE()
							, 'ERROR_MESSAGE() Not Found for @@ERROR: '
								+ COALESCE(CAST(ERROR_NUMBER() AS varchar(16)), 'NULL'));

	--!
	--! Generate a detailed, nicely formatted error message to return to the caller
	--!
	DECLARE @context nvarchar(512); SET @context = COALESCE(NULLIF(@ErrorContext, '') + ' due to ', 'ERROR! ');
	SET @ReturnMessage	= @context
						+ CASE
							WHEN LEN(ERROR_MESSAGE()) > (994 - LEN(@context))
								THEN '"' + SUBSTRING(@ErrorMessage, 1, (994 - LEN(@context))) + '..."'
							ELSE
								'"' + @ErrorMessage + '"'
						  END;

	--!
	--! Session variables (keep it SQL2005 compatible)
	--!
	DECLARE @SessionId	int				; SET @SessionId	= @@SPID;
	DECLARE @ServerName	nvarchar(128)	; SET @ServerName	= @@SERVERNAME;

	--!
	--! log4.SessionInfoOutput variables
	--!
	DECLARE   @HostName				nvarchar(128)
			, @ProgramName			nvarchar(128)
			, @NTDomain				nvarchar(128)
			, @NTUsername			nvarchar(128)
			, @LoginName			nvarchar(128)
			, @OriginalLoginName	nvarchar(128)
			, @SessionLoginTime		datetime

	--! Working variables
	DECLARE @tblExceptionId         table	(ExceptionId int NOT NULL UNIQUE);

	--!
	--! Get the details for the current session
	--!
	EXEC log4Private.SessionInfoOutput
			  @SessionId			= @SessionId
			, @HostName				= @HostName				OUT
			, @ProgramName			= @ProgramName			OUT
			, @NTDomain				= @NTDomain				OUT
			, @NTUsername			= @NTUsername			OUT
			, @LoginName			= @LoginName			OUT
			, @OriginalLoginName	= @OriginalLoginName	OUT
			, @SessionLoginTime		= @SessionLoginTime		OUT

	--!
	--! Record what we have
	--!
	INSERT [log4Private].[SqlException]
	(
	  [ErrorContext]
	, [ErrorNumber]
	, [ErrorSeverity]
	, [ErrorState]
	, [ErrorProcedure]
	, [ErrorLine]
	, [ErrorMessage]
	, [ErrorDatabase]
	, [SessionIdent]
	, [ServerName]
	, [HostName]
	, [ProgramName]
	, [NTDomain]
	, [NTUsername]
	, [LoginName]
	, [OriginalLoginName]
	, [SessionLoginTime]
	)
	OUTPUT inserted.ExceptionId INTO @tblExceptionId
	VALUES
	(
	  @ErrorContext
	, @ErrorNumber
	, @ErrorSeverity
	, @ErrorState
	, @ErrorProcedure
	, @ErrorLine
	, @ErrorMessage
	, @ErrorDatabase
	, @SessionId
	, @ServerName
	, @HostName
	, @ProgramName
	, @NTDomain
	, @NTUsername
	, @LoginName
	, @OriginalLoginName
	, @SessionLoginTime
	);

	SELECT @ExceptionId = ExceptionId FROM @tblExceptionId;

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF;

	RETURN;
END
GO
PRINT N'Creating [privy].[InvoiceControlReset]...';


GO
create procedure [privy].[InvoiceControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.InvoiceControlReset
DESCRIPTION:		Records new, changed and deleted Invoice records (used to identify deltas on the next load)
ORIGIN DATE:		13-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		13-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.InvoiceControl as tgt
		using stg.Invoice as src
			on src.InvoiceKey = tgt.InvoiceKey
		when not matched
			then insert
			(
			  InvoiceKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.InvoiceKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset product control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[CustomerRefresh]...';


GO
create procedure [privy].[CustomerRefresh]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.CustomerRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		set @_Step = 'Collect Runtime Parameters';

		declare @_UnmappedCustomerCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SA_UNMAPPED_CUSTOMER') ;

		declare @_UnmappedCustomerCategoryId int ;
		if len(@_UnmappedCustomerCategory) > 0 and isnumeric(@_UnmappedCustomerCategory) = 1
			set @_UnmappedCustomerCategoryId = cast(@_UnmappedCustomerCategory as int)

		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'

		;with sourceCte
		as
		(
			select
				  c.SYSTEM_ID																								as [QlikViewSourceSystemId]
				, cast(c.CUSTOMER_NO as varchar(50))																		as [NativeCustomerKey]
				, cast(c.CUSTOMER_NO as varchar(50))																		as [CustomerNumber]
				, coalesce(c.CUSTOMER_NAME, '')																				as [CustomerName]
				, coalesce(c.CUSTOMER_ADDRESS_1, '')																		as [CustomerAddress1]
				, coalesce(c.CUSTOMER_ADDRESS_2, '')																		as [CustomerAddress2]
				, coalesce(c.CUSTOMER_ADDRESS_3, '')																		as [CustomerAddress3]
				, coalesce(c.CUSTOMER_ZIPCODE, '')																			as [CustomerZipCode]
				, coalesce(c.CUSTOMER_CITY, '')																				as [CustomerCity]
				, coalesce(c.CUSTOMER_COUNTRY, '')																			as [CustomerCountry]
				, coalesce(c.CUSTOMER_VAT_NO, '')																			as [CustomerVatNumber]
				-----------------------------------------------------------------------------------------------------------------------
				, c.CUSTOMER_TYPE_ID																						as [CustomerTypeId]
				, case
					when c.CUSTOMER_TYPE_ID is null
						then 'Not Specified at Source'
					else coalesce(nullif(c.CUSTOMER_TYPE, ''), 'Not Specified at Source')
					end																										as [CustomerTypeName]
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(c.CUSTOMER_GROUP_1, '')																			as [CustomerGroup1]
				, coalesce(c.CUSTOMER_GROUP_2, '')																			as [CustomerGroup2]
				, coalesce(c.CUSTOMER_GROUP_3, '')																			as [CustomerGroup3]
				, coalesce(c.CUSTOMER_GROUP_4, '')																			as [CustomerGroup4]
				, coalesce(c.CUSTOMER_GROUP_5, '')																			as [CustomerGroup5]
				-----------------------------------------------------------------------------------------------------------------------
				, case when cc.CUSTOMER_CATEGORY_ID is null then 'N' else 'Y' end				as [CategoryIsMapped]
				, coalesce(cast(coalesce(cc.CUSTOMER_CATEGORY_ID, @_UnmappedCustomerCategoryId) as nvarchar(50)), 'N/S')	as [NativeCustomerCategoryKey]
				, coalesce(l1.LeafName, 'Not Specified at Source')															as [CustomerCategoryBaseLevel]
				, coalesce(l1.ParentName, 'Not Specified at Source')														as [CustomerCategoryLevel1]
				, coalesce(l2.ParentName, '')																				as [CustomerCategoryLevel2]
				, coalesce(l3.ParentName, '')																				as [CustomerCategoryLevel3]
				, coalesce(l4.ParentName, '')																				as [CustomerCategoryLevel4]
				, coalesce(l5.ParentName, '')																				as [CustomerCategoryLevel5]
				, coalesce(l6.ParentName, '')																				as [CustomerCategoryLevel6]
				, coalesce(l7.ParentName, '')																				as [CustomerCategoryLevel7]
				, coalesce(l8.ParentName, '')																				as [CustomerCategoryLevel8]
				-----------------------------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(c.CUSTOMER_NAME, 'CUSTOMER_NAME')
					+ coalesce(c.CUSTOMER_ADDRESS_1, 'CUSTOMER_ADDRESS_1')
					+ coalesce(c.CUSTOMER_ADDRESS_2, 'CUSTOMER_ADDRESS_2')
					+ coalesce(c.CUSTOMER_ADDRESS_3, 'CUSTOMER_ADDRESS_3')
					+ coalesce(c.CUSTOMER_ZIPCODE, 'CUSTOMER_ZIPCODE')
					+ coalesce(c.CUSTOMER_CITY, 'CUSTOMER_CITY')
					+ coalesce(c.CUSTOMER_COUNTRY, 'CUSTOMER_COUNTRY')
					+ coalesce(c.CUSTOMER_VAT_NO, 'CUSTOMER_VAT_NO')
				-----------------------------------------------------------------------------------------------------------------------
					+ coalesce(cast(c.CUSTOMER_TYPE_ID as nvarchar(30)), 'CUSTOMER_TYPE_ID')
					+ coalesce(c.CUSTOMER_TYPE, 'CUSTOMER_TYPE')
					+ coalesce(c.CUSTOMER_GROUP_1, 'CUSTOMER_GROUP_1')
					+ coalesce(c.CUSTOMER_GROUP_2, 'CUSTOMER_GROUP_2')
					+ coalesce(c.CUSTOMER_GROUP_3, 'CUSTOMER_GROUP_3')
					+ coalesce(c.CUSTOMER_GROUP_4, 'CUSTOMER_GROUP_4')
					+ coalesce(c.CUSTOMER_GROUP_5, 'CUSTOMER_GROUP_5')
				-----------------------------------------------------------------------------------------------------------------------
					+ case when cc.CUSTOMER_CATEGORY_ID is null then 'N' else 'Y' end
					+ coalesce(cast(coalesce(cc.CUSTOMER_CATEGORY_ID, @_UnmappedCustomerCategoryId) as nvarchar(30)), 'CUSTOMER_CATEGORY_ID')
					+ coalesce(l1.LeafName, 'l1.LeafName')
					+ coalesce(l1.ParentName, 'l1.ParentName')
					+ coalesce(l2.ParentName, 'ParentName')
					+ coalesce(l3.ParentName, 'l3.ParentName')
					+ coalesce(l4.ParentName, 'l4.ParentName')
					+ coalesce(l5.ParentName, 'l5.ParentName')
					+ coalesce(l6.ParentName, 'l6.ParentName')
					+ coalesce(l7.ParentName, 'l7.ParentName')
					+ coalesce(l8.ParentName, 'l8.ParentName')), 2)															as [EtlDeltaHash]
				-----------------------------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].[dbo].[SA_CUSTOMER] as c
			left join [$(Icopal_profBIS)].[dbo].[SA_LINK_CUSTOMER] as lcc
				on lcc.SYSTEM_ID = c.SYSTEM_ID
				and lcc.CUSTOMER_NO = c.CUSTOMER_NO
			left join [$(Icopal_profBIS)].[dbo].[SA_CUSTOMER_CATEGORY] as [cc]
				on cc.CUSTOMER_CATEGORY_ID = coalesce(lcc.CUSTOMER_CATEGORY_ID, @_UnmappedCustomerCategoryId)
			left join stg.CustomerCategoryHierarchy as l1
				on l1.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l1.hNodeFromRoot = 0
			left join stg.CustomerCategoryHierarchy as l2
				on l2.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l2.ParentId = l1.ChildId
				and l2.hNodeFromRoot = l1.hNodeFromRoot + 1
			left join stg.CustomerCategoryHierarchy as l3
				on l3.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l3.ParentId = l2.ChildId
				and l3.hNodeFromRoot = l2.hNodeFromRoot + 1
			left join stg.CustomerCategoryHierarchy as l4
				on l4.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l4.ParentId = l3.ChildId
				and l4.hNodeFromRoot = l3.hNodeFromRoot + 1
			left join stg.CustomerCategoryHierarchy as l5
				on l5.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l5.ParentId = l4.ChildId
				and l5.hNodeFromRoot = l4.hNodeFromRoot + 1
			left join stg.CustomerCategoryHierarchy as l6
				on l6.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l6.ParentId = l5.ChildId
				and l6.hNodeFromRoot = l5.hNodeFromRoot + 1
			left join stg.CustomerCategoryHierarchy as l7
				on l7.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l7.ParentId = l6.ChildId
				and l7.hNodeFromRoot = l6.hNodeFromRoot + 1
			left join stg.CustomerCategoryHierarchy as l8
				on l8.LeafId = cc.CUSTOMER_CATEGORY_ID
				and l8.ParentId = l7.ChildId
				and l8.hNodeFromRoot = l7.hNodeFromRoot + 1
			where
				len(c.CUSTOMER_NO) > 0
		)
		merge into stg.Customer as tgt
		using sourceCte as src
			on src.QlikViewSourceSystemId = tgt.QlikViewSourceSystemId
			and src.NativeCustomerKey collate SQL_Latin1_General_CP1_CI_AS = tgt.NativeCustomerKey collate SQL_Latin1_General_CP1_CI_AS
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, QlikViewSourceSystemId
			, NativeCustomerKey
			, CustomerNumber
			, CustomerName
			, CustomerAddress1
			, CustomerAddress2
			, CustomerAddress3
			, CustomerZipCode
			, CustomerCity
			, CustomerCountry
			, CustomerVatNumber
			, CustomerTypeId
			, CustomerTypeName
			, CustomerGroup1
			, CustomerGroup2
			, CustomerGroup3
			, CustomerGroup4
			, CustomerGroup5
			, CategoryIsMapped
			, NativeCustomerCategoryKey
			, CustomerCategoryBaseLevel
			, CustomerCategoryLevel1
			, CustomerCategoryLevel2
			, CustomerCategoryLevel3
			, CustomerCategoryLevel4
			, CustomerCategoryLevel5
			, CustomerCategoryLevel6
			, CustomerCategoryLevel7
			, CustomerCategoryLevel8
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.QlikViewSourceSystemId
			, src.NativeCustomerKey
			, src.CustomerNumber
			, src.CustomerName
			, src.CustomerAddress1
			, src.CustomerAddress2
			, src.CustomerAddress3
			, src.CustomerZipCode
			, src.CustomerCity
			, src.CustomerCountry
			, src.CustomerVatNumber
			, src.CustomerTypeId
			, src.CustomerTypeName
			, src.CustomerGroup1
			, src.CustomerGroup2
			, src.CustomerGroup3
			, src.CustomerGroup4
			, src.CustomerGroup5
			, src.CategoryIsMapped
			, src.NativeCustomerCategoryKey
			, src.CustomerCategoryBaseLevel
			, src.CustomerCategoryLevel1
			, src.CustomerCategoryLevel2
			, src.CustomerCategoryLevel3
			, src.CustomerCategoryLevel4
			, src.CustomerCategoryLevel5
			, src.CustomerCategoryLevel6
			, src.CustomerCategoryLevel7
			, src.CustomerCategoryLevel8
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.CustomerName = src.CustomerName
					, tgt.CustomerAddress1 = src.CustomerAddress1
					, tgt.CustomerAddress2 = src.CustomerAddress2
					, tgt.CustomerAddress3 = src.CustomerAddress3
					, tgt.CustomerZipCode = src.CustomerZipCode
					, tgt.CustomerCity = src.CustomerCity
					, tgt.CustomerCountry = src.CustomerCountry
					, tgt.CustomerVatNumber = src.CustomerVatNumber
					, tgt.CustomerTypeId = src.CustomerTypeId
					, tgt.CustomerTypeName = src.CustomerTypeName
					, tgt.CustomerGroup1 = src.CustomerGroup1
					, tgt.CustomerGroup2 = src.CustomerGroup2
					, tgt.CustomerGroup3 = src.CustomerGroup3
					, tgt.CustomerGroup4 = src.CustomerGroup4
					, tgt.CustomerGroup5 = src.CustomerGroup5
					, tgt.CategoryIsMapped = src.CategoryIsMapped
					, tgt.NativeCustomerCategoryKey = src.NativeCustomerCategoryKey
					, tgt.CustomerCategoryBaseLevel = src.CustomerCategoryBaseLevel
					, tgt.CustomerCategoryLevel1 = src.CustomerCategoryLevel1
					, tgt.CustomerCategoryLevel2 = src.CustomerCategoryLevel2
					, tgt.CustomerCategoryLevel3 = src.CustomerCategoryLevel3
					, tgt.CustomerCategoryLevel4 = src.CustomerCategoryLevel4
					, tgt.CustomerCategoryLevel5 = src.CustomerCategoryLevel5
					, tgt.CustomerCategoryLevel6 = src.CustomerCategoryLevel6
					, tgt.CustomerCategoryLevel7 = src.CustomerCategoryLevel7
					, tgt.CustomerCategoryLevel8 = src.CustomerCategoryLevel8
		when not matched by source and tgt.CustomerKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh Customer dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[CustomerControlReset]...';


GO
create procedure [privy].[CustomerControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.CustomerControlReset
DESCRIPTION:		Records new, changed and deleted Customer records (used to identify deltas on the next load)
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.CustomerControl as tgt
		using stg.Customer as src
			on src.CustomerKey = tgt.CustomerKey
		when not matched
			then insert
			(
			  CustomerKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.CustomerKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset Customer control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[CustomerCategoryHierarchyRebuild]...';


GO
create procedure [privy].[CustomerCategoryHierarchyRebuild]
(
  @LoadStart datetime
, @RowsAffected int = null out
)

as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.CustomerCategoryHierarchyRebuild
DESCRIPTION:		Truncates and reloads the privy.CustomerCategoryHierarchy table (which is subsequently used to
					generate a flattened and somwhat conformed customer category hierarchy in the dimCustomer view
ORIGIN DATE:		08-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		08-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Truncate'

		truncate table stg.CustomerCategoryHierarchy;

		set @_Step = 'Reload'

		;with customerCategoryLink
		as
		(
				select
					  CUSTOMER_CATEGORY_ID as [LeafId]
					, CUSTOMER_CATEGORY_ID as [ChildId]
					, CUSTOMER_CATEGORY_ID as [ParentId]
					, cast(0 as int) as [hNode]
				from
					[$(Icopal_profBIS)].dbo.SA_CUSTOMER_CATEGORY
			union all
				select
					  c.LeafId
					, p.CUSTOMER_CATEGORY_ID
					, p.CUSTOMER_PARENT_ID
					, hNode + 1
				from
					customerCategoryLink as c
				inner join [$(Icopal_profBIS)].dbo.SA_CUSTOMER_CATEGORY as p
					on p.CUSTOMER_CATEGORY_ID = c.ParentId
				where
						p.CUSTOMER_CATEGORY_ID <> p.CUSTOMER_PARENT_ID -- exclude self-references
					and p.CUSTOMER_PARENT_ID <> c.ChildId -- exclude other other intra-node self-references
		)
		, rootsCte
		as
		(
			select
				  LeafId
				, ParentId as [RootId]
				, row_number() over(partition by LeafId order by hNode desc, ParentId asc) as [RootIdentifier]
			from
				customerCategoryLink
		)
		insert stg.CustomerCategoryHierarchy
		( 
		  LeafId
		, ChildId
		, ParentId
		, RootId
		, hNodeFromLeaf
		, hNodeFromRoot
		, LeafName
		, ChildName
		, ParentName
		, RootName
		, EtlCreatedOn
		)
		select
			  h.LeafId
			, h.ChildId
			, h.ParentId
			, r.RootId
			, h.hNode as [hNodeFromLeaf]
			, row_number() over(partition by h.LeafId order by h.hNode desc) - 1 as [hNodeFromRoot]
			, l.CUSTOMER_CATEGORY_NAME as [LeafName]
			, c.CUSTOMER_CATEGORY_NAME as [ChildName]
			, p.CUSTOMER_CATEGORY_NAME as [ParentName]
			, u.CUSTOMER_CATEGORY_NAME as [RootName]
			, @LoadStart
		from
			customerCategoryLink as h
		inner join rootsCte as r
			on r.LeafId = h.LeafId
			and r.RootIdentifier = 1
		inner join [$(Icopal_profBIS)].dbo.SA_CUSTOMER_CATEGORY as l
			on l.CUSTOMER_CATEGORY_ID = h.LeafId
		inner join [$(Icopal_profBIS)].dbo.SA_CUSTOMER_CATEGORY as c
			on c.CUSTOMER_CATEGORY_ID = h.ChildId
		inner join [$(Icopal_profBIS)].dbo.SA_CUSTOMER_CATEGORY as p
			on p.CUSTOMER_CATEGORY_ID = h.ParentId
		inner join [$(Icopal_profBIS)].dbo.SA_CUSTOMER_CATEGORY as u
			on u.CUSTOMER_CATEGORY_ID = r.RootId

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to rebuild customer category hierarchy at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
	EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[BusinessUnitRefresh]...';


GO
create procedure [privy].[BusinessUnitRefresh]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.BusinessUnitRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'

		;with sourceCte
		as
		(
			select
				  u.SBU										as [NativeBusinessUnitKey]
				, coalesce(u.SBU, '')						as [StrategicBusinessUnitCode]
				, coalesce(u.SALESCENTER_SBU, '')			as [SalesCenterSbuCode]
				, coalesce(u.SBU_NAME, '')					as [BusinessUnitName]
				, u.REGION_ID								as [RegionId]
				, coalesce(r.REGION, '')					as [RegionName]
				, coalesce(r.REGION_DESCRIPTION, '')		as [RegionDescription]
				---------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(u.SALESCENTER_SBU, 'SALESCENTER_SBU')
					+ coalesce(u.SBU_NAME, 'SBU_NAME')
					+ coalesce(cast(u.REGION_ID as nvarchar(30)), 'REGION_ID')
					+ coalesce(r.REGION, 'REGION')
					+ coalesce(r.REGION_DESCRIPTION, 'REGION_DESCRIPTION')), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].[dbo].[V_MD_SBU_SABIS] as u
			left join [$(Icopal_profBIS)].[dbo].[MD_REGION] as r
				on u.REGION_ID = r.REGION_ID
		)
		merge into stg.BusinessUnit as tgt
		using sourceCte as src
			on src.NativeBusinessUnitKey collate SQL_Latin1_General_CP1_CI_AS = tgt.NativeBusinessUnitKey collate SQL_Latin1_General_CP1_CI_AS
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, NativeBusinessUnitKey
			, StrategicBusinessUnitCode
			, SalesCenterSbuCode
			, BusinessUnitName
			, RegionId
			, RegionName
			, RegionDescription
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.NativeBusinessUnitKey
			, src.StrategicBusinessUnitCode
			, src.SalesCenterSbuCode
			, src.BusinessUnitName
			, src.RegionId
			, src.RegionName
			, src.RegionDescription
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.StrategicBusinessUnitCode = src.StrategicBusinessUnitCode
					, tgt.SalesCenterSbuCode = src.SalesCenterSbuCode
					, tgt.BusinessUnitName = src.BusinessUnitName
					, tgt.RegionId = src.RegionId
					, tgt.RegionName = src.RegionName
					, tgt.RegionDescription = src.RegionDescription
		when not matched by source and tgt.BusinessUnitKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh BusinessUnit dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[BusinessUnitControlReset]...';


GO
create procedure [privy].[BusinessUnitControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.BusinessUnitControlReset
DESCRIPTION:		Records new, changed and deleted Business Unit records (used to identify deltas on the next load)
ORIGIN DATE:		16-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		16-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.BusinessUnitControl as tgt
		using stg.BusinessUnit as src
			on src.BusinessUnitKey = tgt.BusinessUnitKey
		when not matched
			then insert
			(
			  BusinessUnitKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.BusinessUnitKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset Business Unit control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[ProductCategoryHierarchyRebuild]...';


GO
create procedure [privy].[ProductCategoryHierarchyRebuild]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.ProductCategoryHierarchyRebuild
DESCRIPTION:		Truncates and reloads the privy.ProductCategoryHierarchy table (which is subsequently used to
					generate a flattened and somwhat conformed product category hierarchy in the dimProduct view
ORIGIN DATE:		08-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		08-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Truncate'

		truncate table stg.ProductCategoryHierarchy;

		--!
		--!
		--!
		set @_Step = 'Reload'

		;with productCategoryLink
		as
		(
				select
					  ITEM_CATEGORY_ID as [LeafId]
					, ITEM_CATEGORY_ID as [ChildId]
					, ITEM_CATEGORY_ID as [ParentId]
					, cast(0 as int) as [hNode]
				from
					[$(Icopal_profBIS)].dbo.SA_ITEM_CATEGORY
			union all
				select
					  c.LeafId
					, p.ITEM_CATEGORY_ID
					, p.ITEM_PARENT_ID
					, hNode + 1
				from
					productCategoryLink as c
				inner join [$(Icopal_profBIS)].dbo.SA_ITEM_CATEGORY as p
					on p.ITEM_CATEGORY_ID = c.ParentId
				where
						p.ITEM_CATEGORY_ID <> p.ITEM_PARENT_ID -- exclude self-references
					and p.ITEM_PARENT_ID <> c.ChildId -- exclude other other intra-node self-references
		)
		, rootsCte
		as
		(
			select
				  LeafId
				, ParentId as [RootId]
				, row_number() over(partition by LeafId order by hNode desc, ParentId asc) as [RootIdentifier]
			from
				productCategoryLink
		)
		insert stg.ProductCategoryHierarchy
		( 
		  LeafId
		, ChildId
		, ParentId
		, RootId
		, hNodeFromLeaf
		, hNodeFromRoot
		, LeafName
		, ChildName
		, ParentName
		, RootName
		, EtlCreatedOn
		)
		select
			  h.LeafId
			, h.ChildId
			, h.ParentId
			, r.RootId
			, h.hNode as [hNodeFromLeaf]
			, row_number() over(partition by h.LeafId order by h.hNode desc) - 1 as [hNodeFromRoot]
			, l.ITEM_CATEGORY_NAME as [LeafName]
			, c.ITEM_CATEGORY_NAME as [ChildName]
			, p.ITEM_CATEGORY_NAME as [ParentName]
			, u.ITEM_CATEGORY_NAME as [RootName]
			, @LoadStart
		from
			ProductCategoryLink as h
		inner join rootsCte as r
			on r.LeafId = h.LeafId
			and r.RootIdentifier = 1
		inner join [$(Icopal_profBIS)].dbo.SA_ITEM_CATEGORY as l
			on l.ITEM_CATEGORY_ID = h.LeafId
		inner join [$(Icopal_profBIS)].dbo.SA_ITEM_CATEGORY as c
			on c.ITEM_CATEGORY_ID = h.ChildId
		inner join [$(Icopal_profBIS)].dbo.SA_ITEM_CATEGORY as p
			on p.ITEM_CATEGORY_ID = h.ParentId
		inner join [$(Icopal_profBIS)].dbo.SA_ITEM_CATEGORY as u
			on u.ITEM_CATEGORY_ID = r.RootId

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to rebuild product category hierarchy at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
	EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[ProductCategoryControlReset]...';


GO
create procedure [privy].[ProductCategoryControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.ProductCategoryControlReset
DESCRIPTION:		Records new, changed and deleted Product Category records (used to identify deltas on the next load)
ORIGIN DATE:		19-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		19-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.ProductCategoryControl as tgt
		using stg.ProductCategory as src
			on src.ProductCategoryKey = tgt.ProductCategoryKey
		when not matched
			then insert
			(
			  ProductCategoryKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.ProductCategoryKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset Product Category control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[PaymentTermRefresh]...';


GO
create procedure [privy].[PaymentTermRefresh]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.PaymentTermRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'

		;with sourceCte
		as
		(
			select
				  cast(PAYMENTTERM_ID as nvarchar(50)) as [NativePaymentTermKey]
				, coalesce(nullif(PAYMENTTERM_NAME, ''), cast([DAYS] as varchar(16)) + ' day(s)') as [PaymentTermName]
				, [DAYS] as [PaymentTermDays]
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(PAYMENTTERM_NAME, 'PAYMENTTERM_NAME')
					+ coalesce(cast([DAYS] as nvarchar(30)), 'DAYS')), 2) as [EtlDeltaHash]
			from
				[$(Icopal_profBIS)].[dbo].[PU_PAYMENTTERM]
			--! No point processing invalid payment terms
			where
				len(PAYMENTTERM_NAME) > 0 or [DAYS] is not null
		)
		merge into stg.PaymentTerm as tgt
		using sourceCte as src
			on src.NativePaymentTermKey collate SQL_Latin1_General_CP1_CI_AS = tgt.NativePaymentTermKey collate SQL_Latin1_General_CP1_CI_AS
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, NativePaymentTermKey
			, PaymentTermName
			, PaymentTermDays
			, PaymentTermDescription
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.NativePaymentTermKey
			, src.PaymentTermName
			, src.PaymentTermDays
			, ''
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.PaymentTermName = src.PaymentTermName
					, tgt.PaymentTermDays = src.PaymentTermDays
		when not matched by source and tgt.PaymentTermKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh PaymentTerm dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[PaymentTermControlReset]...';


GO
create procedure [privy].[PaymentTermControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.PaymentTermControlReset
DESCRIPTION:		Records new, changed and deleted PaymentTerm records (used to identify deltas on the next load)
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.PaymentTermControl as tgt
		using stg.PaymentTerm as src
			on src.PaymentTermKey = tgt.PaymentTermKey
		when not matched
			then insert
			(
			  PaymentTermKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.PaymentTermKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset PaymentTerm control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[OrderShippedNotInvoicedControlReset]...';


GO
create procedure [privy].[OrderShippedNotInvoicedControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.OrderShippedNotInvoicedControlReset
DESCRIPTION:		Records new, changed and deleted Order (SNI) records (used to identify deltas on the next load)
ORIGIN DATE:		14-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		14-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.OrderShippedNotInvoicedControl as tgt
		using stg.OrderShippedNotInvoiced as src
			on src.OrderShippedNotInvoicedKey = tgt.OrderShippedNotInvoicedKey
		when not matched
			then insert
			(
			  OrderShippedNotInvoicedKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.OrderShippedNotInvoicedKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset OrderShippedNotInvoiced control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[OrderBacklogControlReset]...';


GO
create procedure [privy].[OrderBacklogControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.OrderBacklogControlReset
DESCRIPTION:		Records new, changed and deleted Order (SNI) records (used to identify deltas on the next load)
ORIGIN DATE:		15-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		15-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.OrderBacklogControl as tgt
		using stg.OrderBacklog as src
			on src.OrderBacklogKey = tgt.OrderBacklogKey
		when not matched
			then insert
			(
			  OrderBacklogKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.OrderBacklogKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset OrderBacklog control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[SiteRefresh]...';


GO
create procedure [privy].[SiteRefresh]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.SiteRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'

		;with sourceCte
		as
		(
			select
				  cast(si.SITE_ID as nvarchar(50))			as [NativeSiteKey]
				, coalesce(si.NAME, '')						as [SiteName]
				, coalesce(si.SITE_DESCRIPTION, '')			as [SiteDescription]
				, coalesce(si.SBU, '')						as [StrategicBusinessUnitCode]
				, coalesce(u.SALESCENTER_SBU, '')			as [SalesCenterSbuCode]
				, coalesce(u.SBU_NAME, '')					as [BusinessUnitName]
				, u.REGION_ID								as [RegionId]
				, coalesce(r.REGION, '')					as [RegionName]
				, coalesce(r.REGION_DESCRIPTION, '')		as [RegionDescription]
				, si.SYSTEM_ID								as [SourceSystemId]
				, coalesce(sy.NAME, '')						as [SourceSystemName]
				---------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(si.NAME, 'si.NAME')
					+ coalesce(si.SITE_DESCRIPTION, 'SITE_DESCRIPTION')
					+ coalesce(si.SBU, 'SBU')
					+ coalesce(u.SALESCENTER_SBU, 'SALESCENTER_SBU')
					+ coalesce(u.SBU_NAME, 'SBU_NAME')
					+ coalesce(cast(u.REGION_ID as nvarchar(30)), 'REGION_ID')
					+ coalesce(r.REGION, 'REGION')
					+ coalesce(r.REGION_DESCRIPTION, 'REGION_DESCRIPTION')
					+ coalesce(cast(si.SYSTEM_ID as nvarchar(30)), 'SYSTEM_ID')
					+ coalesce(sy.NAME, 'sy.NAME')), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].[dbo].[V_MD_SBU_SABIS] as u
			inner join [$(Icopal_profBIS)].[dbo].[MD_SITE] as si
				on u.SBU = si.SBU
			left join [$(Icopal_profBIS)].[dbo].[MD_SYSTEMID] as [sy]
				on sy.SYSTEM_ID = si.SYSTEM_ID
			left join [$(Icopal_profBIS)].[dbo].[MD_REGION] as r
				on u.REGION_ID = r.REGION_ID
		)
		merge into stg.Site as tgt
		using sourceCte as src
			on src.NativeSiteKey collate SQL_Latin1_General_CP1_CI_AS = tgt.NativeSiteKey collate SQL_Latin1_General_CP1_CI_AS
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, NativeSiteKey
			, SiteName
			, SiteDescription
			, StrategicBusinessUnitCode
			, SalesCenterSbuCode
			, BusinessUnitName
			, RegionId
			, RegionName
			, RegionDescription
			, SourceSystemId
			, SourceSystemName
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.NativeSiteKey
			, src.SiteName
			, src.SiteDescription
			, src.StrategicBusinessUnitCode
			, src.SalesCenterSbuCode
			, src.BusinessUnitName
			, src.RegionId
			, src.RegionName
			, src.RegionDescription
			, src.SourceSystemId
			, src.SourceSystemName
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.SiteName = src.SiteName
					, tgt.SiteDescription = src.SiteDescription
					, tgt.StrategicBusinessUnitCode = src.StrategicBusinessUnitCode
					, tgt.SalesCenterSbuCode = src.SalesCenterSbuCode
					, tgt.BusinessUnitName = src.BusinessUnitName
					, tgt.RegionId = src.RegionId
					, tgt.RegionName = src.RegionName
					, tgt.RegionDescription = src.RegionDescription
					, tgt.SourceSystemId = src.SourceSystemId
					, tgt.SourceSystemName = src.SourceSystemName
		when not matched by source and tgt.SiteKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh Site dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[SiteControlReset]...';


GO
create procedure [privy].[SiteControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.SiteControlReset
DESCRIPTION:		Records new, changed and deleted Site records (used to identify deltas on the next load)
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.SiteControl as tgt
		using stg.Site as src
			on src.SiteKey = tgt.SiteKey
		when not matched
			then insert
			(
			  SiteKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.SiteKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset Site control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[ProductRefresh]...';


GO
create procedure [privy].[ProductRefresh]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.ProductRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		08-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		08-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		set @_Step = 'Collect Runtime Parameters';

		declare @_UnmappedProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SA_UNMAPPED_ITEM') ;

		declare @_UnmappedProductCategoryId int ;
		if len(@_UnmappedProductCategory) > 0 and isnumeric(@_UnmappedProductCategory) = 1
			set @_UnmappedProductCategoryId = cast(@_UnmappedProductCategory as int)

		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'

		;with sourceCte
		as
		(
			select
				  p.SYSTEM_ID													as [QlikViewSourceSystemId]
				, cast(p.ITEM_NO as nvarchar(50))								as [NativeProductKey]
				, p.ITEM_NO														as [ProductNumber]
				, coalesce(p.ITEM_NAME, 'NOT SPECIFIED AT SOURCE')				as [ProductName]
				, coalesce(p.ITEM_TYPE_ID, 9)									as [ProductTypeId]
				, coalesce(p.ITEM_TYPE, 'UNKNOWN')								as [ProductTypeName]
				, coalesce(p.ITEM_GNIT, '')										as [ProductGnit]
				, coalesce(p.ITEM_DESCRIPTION_1, '')							as [ProductDescription1]
				, coalesce(p.ITEM_DESCRIPTION_2, '')							as [ProductDescription2]
				, coalesce(p.ITEM_GROUP_1, '')									as [LocalProductGroup1]
				, coalesce(p.ITEM_GROUP_2, '')									as [LocalProductGroup2]
				, coalesce(p.ITEM_GROUP_3, '')									as [LocalProductGroup3]
				, coalesce(p.ITEM_GROUP_4, '')									as [LocalProductGroup4]
				, coalesce(p.ITEM_GROUP_5, '')									as [LocalProductGroup5]
				, coalesce(ic.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId)	as [NativeProductCategoryKey]
				, coalesce(pc.ProductCategoryName, 'NOT SPECIFIED AT SOURCE')	as [ProductCategoryBaseLevel]
				, coalesce(pc.Level1Id, -1)										as [ProductCategoryLevel1Id]
				, coalesce(pc.Level1Name, 'NOT SPECIFIED AT SOURCE')			as [ProductCategoryLevel1]
				, coalesce(pc.Level2Id, -1)										as [ProductCategoryLevel2Id]
				, coalesce(pc.Level2Name, 'NOT SPECIFIED AT SOURCE')			as [ProductCategoryLevel2]
				, coalesce(pc.Level3Id, -1)										as [ProductCategoryLevel3Id]
				, coalesce(pc.Level3Name, 'NOT SPECIFIED AT SOURCE')			as [ProductCategoryLevel3]
				, cast(null as int)												as [ProductCategoryLevel4Id]
				, ''															as [ProductCategoryLevel4]
				, cast(null as int)												as [ProductCategoryLevel5Id]
				, ''															as [ProductCategoryLevel5]
				, cast(null as int)												as [ProductCategoryLevel6Id]
				, ''															as [ProductCategoryLevel6]
				---------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(p.ITEM_NAME, 'ITEM_NAME')
					+ coalesce(cast(p.ITEM_TYPE_ID as nvarchar(30)), 'ITEM_TYPE_ID')
					+ coalesce(p.ITEM_TYPE, 'ITEM_TYPE')
					+ coalesce(p.ITEM_GNIT, 'ITEM_GNIT')
					+ coalesce(p.ITEM_DESCRIPTION_1, 'ITEM_DESCRIPTION_1')
					+ coalesce(p.ITEM_DESCRIPTION_2, 'ITEM_DESCRIPTION_2')
					+ coalesce(p.ITEM_GROUP_1, 'ITEM_GROUP_1')
					+ coalesce(p.ITEM_GROUP_2, 'ITEM_GROUP_2')
					+ coalesce(p.ITEM_GROUP_3, 'ITEM_GROUP_3')
					+ coalesce(p.ITEM_GROUP_4, 'ITEM_GROUP_4')
					+ coalesce(p.ITEM_GROUP_5, 'ITEM_GROUP_5')
					+ coalesce(cast(coalesce(ic.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as nvarchar(30)), 'ITEM_CATEGORY_ID')
					+ coalesce(pc.ProductCategoryName, 'pc.ProductCategoryName')
					+ coalesce(cast(pc.Level1Id as nvarchar(30)), 'pc.Level1Id')
					+ coalesce(pc.Level1Name, 'pc.Level1Name')
					+ coalesce(cast(pc.Level2Id as nvarchar(30)), 'pc.Level2Id')
					+ coalesce(pc.Level2Name, 'pc.Level2Name')
					+ coalesce(cast(pc.Level3Id as nvarchar(30)), 'pc.Level3Id')
					+ coalesce(pc.Level3Name, 'pc.Level3Name')
					+ 'Level4Id'
					+ 'Level4Name'
					+ 'Level5Id'
					+ 'Level5Name'
					+ 'Level6Id'
					+ 'Level6Name'), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].[dbo].[MD_ITEMS] as p
			inner join [$(Icopal_profBIS)].[dbo].[SA_LINK_ITEM] as ic
				on ic.SYSTEM_ID = p.SYSTEM_ID
				and ic.ITEM_NO = p.ITEM_NO
			inner join stg.ProductCategory as pc
				on pc.NativeProductCategoryKey = cast(coalesce(ic.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as nvarchar(50))
		)
		merge into stg.Product as tgt
		using sourceCte as src
			on src.QlikViewSourceSystemId = tgt.QlikViewSourceSystemId
			and src.NativeProductKey collate SQL_Latin1_General_CP1_CI_AS = tgt.NativeProductKey collate SQL_Latin1_General_CP1_CI_AS
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, QlikViewSourceSystemId
			, NativeProductKey
			, ProductNumber
			, ProductName
			, ProductTypeId
			, ProductTypeName
			, ProductGnit
			, ProductDescription1
			, ProductDescription2
			, LocalProductGroup1
			, LocalProductGroup2
			, LocalProductGroup3
			, LocalProductGroup4
			, LocalProductGroup5
			, NativeProductCategoryKey
			, ProductCategoryBaseLevel
			, ProductCategoryLevel1Id
			, ProductCategoryLevel1
			, ProductCategoryLevel2Id
			, ProductCategoryLevel2
			, ProductCategoryLevel3Id
			, ProductCategoryLevel3
			, ProductCategoryLevel4Id
			, ProductCategoryLevel4
			, ProductCategoryLevel5Id
			, ProductCategoryLevel5
			, ProductCategoryLevel6Id
			, ProductCategoryLevel6
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.QlikViewSourceSystemId
			, src.NativeProductKey
			, src.ProductNumber
			, src.ProductName
			, src.ProductTypeId
			, src.ProductTypeName
			, src.ProductGnit
			, src.ProductDescription1
			, src.ProductDescription2
			, src.LocalProductGroup1
			, src.LocalProductGroup2
			, src.LocalProductGroup3
			, src.LocalProductGroup4
			, src.LocalProductGroup5
			, src.NativeProductCategoryKey
			, src.ProductCategoryBaseLevel
			, src.ProductCategoryLevel1Id
			, src.ProductCategoryLevel1
			, src.ProductCategoryLevel2Id
			, src.ProductCategoryLevel2
			, src.ProductCategoryLevel3Id
			, src.ProductCategoryLevel3
			, src.ProductCategoryLevel4Id
			, src.ProductCategoryLevel4
			, src.ProductCategoryLevel5Id
			, src.ProductCategoryLevel5
			, src.ProductCategoryLevel6Id
			, src.ProductCategoryLevel6
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.ProductName = src.ProductName
					, tgt.ProductTypeId = src.ProductTypeId
					, tgt.ProductTypeName = src.ProductTypeName
					, tgt.ProductGnit = src.ProductGnit
					, tgt.ProductDescription1 = src.ProductDescription1
					, tgt.ProductDescription2 = src.ProductDescription2
					, tgt.LocalProductGroup1 = src.LocalProductGroup1
					, tgt.LocalProductGroup2 = src.LocalProductGroup2
					, tgt.LocalProductGroup3 = src.LocalProductGroup3
					, tgt.LocalProductGroup4 = src.LocalProductGroup4
					, tgt.LocalProductGroup5 = src.LocalProductGroup5
					, tgt.NativeProductCategoryKey = src.NativeProductCategoryKey
					, tgt.ProductCategoryBaseLevel = src.ProductCategoryBaseLevel
					, tgt.ProductCategoryLevel1Id = src.ProductCategoryLevel1Id
					, tgt.ProductCategoryLevel1 = src.ProductCategoryLevel1
					, tgt.ProductCategoryLevel2Id = src.ProductCategoryLevel2Id
					, tgt.ProductCategoryLevel2 = src.ProductCategoryLevel2
					, tgt.ProductCategoryLevel3Id = src.ProductCategoryLevel3Id
					, tgt.ProductCategoryLevel3 = src.ProductCategoryLevel3
					, tgt.ProductCategoryLevel4Id = src.ProductCategoryLevel4Id
					, tgt.ProductCategoryLevel4 = src.ProductCategoryLevel4
					, tgt.ProductCategoryLevel5Id = src.ProductCategoryLevel5Id
					, tgt.ProductCategoryLevel5 = src.ProductCategoryLevel5
					, tgt.ProductCategoryLevel6Id = src.ProductCategoryLevel6Id
					, tgt.ProductCategoryLevel6 = src.ProductCategoryLevel6
		when not matched by source and tgt.ProductKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh product dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[ProductControlReset]...';


GO
create procedure [privy].[ProductControlReset]
(
  @LoadEnd datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.ProductControlReset
DESCRIPTION:		Records new, changed and deleted Product records (used to identify deltas on the next load)
ORIGIN DATE:		08-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		08-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);
	declare	@_Now datetime = getdate();

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Control'

		merge into stg.ProductControl as tgt
		using stg.Product as src
			on src.ProductKey = tgt.ProductKey
		when not matched
			then insert
			(
			  ProductKey
			, PreviousDeltaHash
			, IsDeleted
			, LastTouchedOn
			)
			values
			(
			  src.ProductKey
			, src.EtlDeltaHash
			, src.IsDeleted
			, @LoadEnd
			)
		when matched and tgt.PreviousDeltaHash <> src.EtlDeltaHash
			or tgt.IsDeleted <> src.IsDeleted
		then update set
			  tgt.PreviousDeltaHash = src.EtlDeltaHash
			, tgt.IsDeleted = src.IsDeleted
			, tgt.LastTouchedOn = @LoadEnd
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to reset product control at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[ProductCategoryRefresh]...';


GO
create procedure [privy].[ProductCategoryRefresh]
(
  @LoadStart datetime
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.ProductCategoryRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		19-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		19-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_ReturnValue int
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_Step varchar(128);

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'

		; with leafNode4Cte
		as
		(
			select
				LeafId
			from
				stg.ProductCategoryHierarchy
			where
					hNodeFromLeaf = 0
				and hNodeFromRoot = (select max(hNodeFromRoot) from stg.ProductCategoryHierarchy)
		)
		, leafNode3Cte
		as
		(
			select
				LeafId
			from
				stg.ProductCategoryHierarchy
			where
					hNodeFromLeaf = 0
				and hNodeFromRoot = 2
		)
		, leafNode2Cte
		as
		(
			select
				LeafId
			from
				stg.ProductCategoryHierarchy
			where
					hNodeFromLeaf = 0
				and hNodeFromRoot = 1
		)
		, catageoriesCte
		as
		(
				select
					  x.ChildId as [ProductCategoryId]
					, x.ChildName as [ProductCategoryName]
					, cast(4 as tinyint) as [NodeDepth]
					, y.ChildId as [Level3Id]
					, y.ChildName as [Level3Name]
					, z.ChildId as [Level2Id]
					, z.ChildName as [Level2Name]
					, z.ParentId as [Level1Id]
					, z.ParentName as [Level1Name]
				from
					leafNode4Cte as leaf
				inner join stg.ProductCategoryHierarchy as x
					on x.LeafId = leaf.LeafId
					and x.hNodeFromLeaf = 1
				left join stg.ProductCategoryHierarchy as y
					on y.LeafId = leaf.LeafId
					and y.ChildId = x.ParentId
					and y.hNodeFromLeaf = x.hNodeFromLeaf + 1
				left join stg.ProductCategoryHierarchy as z
					on z.LeafId = leaf.LeafId
					and z.ChildId = y.ParentId
					and z.hNodeFromLeaf = y.hNodeFromLeaf + 1
			union all
				select 
					  x.ChildId as [ProductCategoryId]
					, x.ChildName as [ProductCategoryName]
					, cast(3 as tinyint) as [NodeDepth]
					, x.ChildId as [Level3Id]
					, x.ChildName as [Level3Name]
					, y.ChildId as [Level2Id]
					, y.ChildName as [Level2Name]
					, y.ParentId as [Level1Id]
					, y.ParentName as [Level1Name]
				from
					leafNode3Cte as leaf
				inner join stg.ProductCategoryHierarchy as x
					on x.LeafId = leaf.LeafId
					and x.hNodeFromLeaf = 1
				left join stg.ProductCategoryHierarchy as y
					on y.LeafId = leaf.LeafId
					and y.ChildId = x.ParentId
					and y.hNodeFromLeaf = x.hNodeFromLeaf + 1
			union all
				select 
					  x.ChildId as [ProductCategoryId]
					, x.ChildName as [ProductCategoryName]
					, cast(2 as tinyint) as [NodeDepth]
					, x.ChildId as [Level3Id]
					, x.ChildName as [Level3Name]
					, x.ChildId as [Level2Id]
					, x.ChildName as [Level2Name]
					, x.ParentId as [Level1Id]
					, x.ParentName as [Level1Name]
				from
					leafNode2Cte as leaf
				inner join stg.ProductCategoryHierarchy as x
					on x.LeafId = leaf.LeafId
					and x.hNodeFromLeaf = 1
			union all
				select 
					  x.ChildId as [ProductCategoryId]
					, x.ChildName as [ProductCategoryName]
					, cast(1 as tinyint) as [NodeDepth]
					, x.ChildId as [Level3Id]
					, x.ChildName as [Level3Name]
					, x.ChildId as [Level2Id]
					, x.ChildName as [Level2Name]
					, x.ChildId as [Level2Id]
					, x.ChildName as [Level2Name]
				from
					stg.ProductCategoryHierarchy as x
				where
						x.hNodeFromRoot = 0
					and x.hNodeFromLeaf = 0
		)
		, sourceCte
		as
		(
			select
				  cast(c.ProductCategoryId as nvarchar(50)) as [NativeProductCategoryKey]
				, c.ProductCategoryId
				, c.ProductCategoryName
				, c.NodeDepth
				, c.Level3Id
				, c.Level3Name
				, c.Level2Id
				, c.Level2Name
				, c.Level1Id
				, c.Level1Name
				, '' as [ProductCategoryDescription]
				---------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(c.ProductCategoryName, 'ProductCategoryName')
					+ coalesce(cast(c.NodeDepth as nvarchar(30)), 'NodeDepth')
					+ coalesce(cast(c.Level3Id as nvarchar(30)), 'Level3Id')
					+ coalesce(c.Level3Name, 'Level3Name')
					+ coalesce(cast(c.Level2Id as nvarchar(30)), 'Level2Id')
					+ coalesce(c.Level2Name, 'Level2Name')
					+ coalesce(cast(c.Level1Id as nvarchar(30)), 'Level1Id')
					+ coalesce(c.Level1Name, 'Level1Name')
					+ 'ProductCategoryDescription'), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				catageoriesCte as c

		)
		merge into stg.ProductCategory as tgt
		using sourceCte as src
			on src.NativeProductCategoryKey collate SQL_Latin1_General_CP1_CI_AS = tgt.NativeProductCategoryKey collate SQL_Latin1_General_CP1_CI_AS
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, NativeProductCategoryKey
			, ProductCategoryId
			, ProductCategoryName
			, NodeDepth
			, Level3Id
			, Level3Name
			, Level2Id
			, Level2Name
			, Level1Id
			, Level1Name
			, ProductCategoryDescription
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.NativeProductCategoryKey
			, src.ProductCategoryId
			, src.ProductCategoryName
			, src.NodeDepth
			, src.Level3Id
			, src.Level3Name
			, src.Level2Id
			, src.Level2Name
			, src.Level1Id
			, src.Level1Name
			, src.ProductCategoryDescription
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, ProductCategoryName = src.ProductCategoryName
					, NodeDepth = src.NodeDepth
					, tgt.Level3Id = src.Level3Id
					, tgt.Level3Name = src.Level3Name
					, tgt.Level2Id = src.Level2Id
					, tgt.Level2Name = src.Level2Name
					, tgt.Level1Id = src.Level1Id
					, tgt.Level1Name = src.Level1Name
					, tgt.ProductCategoryDescription = src.ProductCategoryDescription
		when not matched by source and tgt.ProductCategoryKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;

		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh ProductCategory dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [log4].[JournalWriter]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4].[JournalWriter]
(
  @FunctionName			varchar(256)
, @MessageText			varchar(512)
, @ExtraInfo			varchar(max)	= NULL
, @DatabaseName			nvarchar(128)	= NULL
, @Task					nvarchar(128)	= NULL
, @StepInFunction		varchar(128)	= NULL
, @Severity				smallint		= NULL
, @ExceptionId			int				= NULL
, @JournalId			int				= NULL OUT
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4].[JournalWriter]
DESCRIPTION:		Adds a journal entry summarising task progress, completion or failure msgs etc.
DATE OF ORIGIN:		01-DEC-2006
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:			Various
DEPENDENCIES:		[log4Private].[SessionInfoOutput]
					[log4].[ExceptionHandler]

Returns
=======
@@ERROR - always zero on success

Additional Notes
================
Possible options for @Severity

   1 -- Showstopper/Critical Failure
   2 -- Severe Failure
   4 -- Major Failure
   8 -- Moderate Failure
  16 -- Minor Failure
  32 -- Concurrency Violation
  64 -- Reserved for future Use
 128 -- Reserved for future Use
 256 -- Informational
 512 -- Success
1024 -- Debug
2048 -- Reserved for future Use
4096 -- Reserved for future Use



Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
01-DEC-2006		GML		v0.0.1		Created
------------	------	-------		--------------------------------------------------------------
15-APR-2008		GML		v0.0.3		Now utilises [log4Private].[SessionInfoOutput] sproc for session values
------------	------	-------		--------------------------------------------------------------
03-MAY-2011		GML		v0.0.4		Added support for JournalDetail table
------------	------	-------		--------------------------------------------------------------
28-AUG-2011		GML		v0.0.6		Added support for ExceptionId and Task columns
------------	------	-------		--------------------------------------------------------------

=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET NOCOUNT ON

	DECLARE @Error int; SET @Error = 0;

	--!
	--! Define input defaults
	--!
	SET @DatabaseName	= COALESCE(@DatabaseName, DB_NAME())
	SET @FunctionName	= COALESCE(@FunctionName, '')
	SET @StepInFunction	= COALESCE(@StepInFunction, '')
	SET @MessageText	= COALESCE(@MessageText, '')
	SET @ExtraInfo		= COALESCE(@ExtraInfo, '')
	SET @Task			= COALESCE(@Task, '')

	--! Make sure the supplied severity fits our bitmask model
	IF ISNULL(@Severity, 0) NOT IN (1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096)
		BEGIN
			SET @ExtraInfo  = COALESCE(NULLIF(@ExtraInfo, '') + CHAR(13), '')
							+ '(Severity value: ' + COALESCE(CAST(@Severity AS varchar(4)), 'NULL') + ' is invalid so using 256)'
			SET @Severity   = 256 -- Informational
		END

	--!
	--! Session variables (keep it SQL2005 compatible)
	--!
	DECLARE @SessionId	int				; SET @SessionId	= @@SPID;
	DECLARE @ServerName	nvarchar(128)	; SET @ServerName	= @@SERVERNAME;

	--!
	--! log4.SessionInfoOutput variables
	--!
	DECLARE   @HostName				nvarchar(128)
			, @ProgramName			nvarchar(128)
			, @NTDomain				nvarchar(128)
			, @NTUsername			nvarchar(128)
			, @LoginName			nvarchar(128)
			, @OriginalLoginName	nvarchar(128)
			, @SessionLoginTime		datetime


	--!
	--! Get the details for the current session
	--!
	EXEC log4Private.SessionInfoOutput
			  @SessionId			= @SessionId
			, @HostName				= @HostName				OUT
			, @ProgramName			= @ProgramName			OUT
			, @NTDomain				= @NTDomain				OUT
			, @NTUsername			= @NTUsername			OUT
			, @LoginName			= @LoginName			OUT
			, @OriginalLoginName	= @OriginalLoginName	OUT
			, @SessionLoginTime		= @SessionLoginTime		OUT

	--! Working variables
	DECLARE @tblJournalId table	(JournalId int NOT NULL UNIQUE);

	BEGIN TRY
		INSERT [log4Private].[Journal]
		(
		  [Task]
		, [FunctionName]
		, [StepInFunction]
		, [MessageText]
		, [SeverityId]
		, [ExceptionId]
		------------------------
		, [SessionId]
		, [ServerName]
		, [DatabaseName]
		, [HostName]
		, [ProgramName]
		, [NTDomain]
		, [NTUsername]
		, [LoginName]
		, [OriginalLoginName]
		, [SessionLoginTime]
		)
	OUTPUT inserted.JournalId INTO @tblJournalId
	VALUES
		(
		  @Task
		, @FunctionName
		, @StepInFunction
		, @MessageText
		, @Severity
		, @ExceptionId
		------------------------
		, @SessionId
		, @ServerName
		, @DatabaseName
		, @HostName
		, @ProgramName
		, @NTDomain
		, @NTUsername
		, @LoginName
		, @OriginalLoginName
		, @SessionLoginTime
		)

		SELECT @JournalId = JournalId FROM @tblJournalId;

		INSERT [log4Private].[JournalDetail]
		(
		  JournalId
		, ExtraInfo
		)
		VALUES
		(
		  @JournalId
		, @ExtraInfo
		)

	END TRY
	BEGIN CATCH
		--!
		--! If we have an uncommitable transaction (XACT_STATE() = -1), if we hit a deadlock
		--! or if @@TRANCOUNT > 0 AND XACT_STATE() != 1, we HAVE to roll back.
		--! Otherwise, leaving it to the calling process
		--!
		IF (@@TRANCOUNT > 0 AND XACT_STATE() != 1) OR (XACT_STATE() = -1) OR (ERROR_NUMBER() = 1205)
			BEGIN
				ROLLBACK TRAN

				SET @MessageText    = 'Failed to write journal entry: '
									+ CASE
										WHEN LEN(@MessageText) > 440
											THEN '"' + SUBSTRING(@MessageText, 1, 440) + '..."'
										ELSE
											COALESCE('"' + @MessageText + '"', 'NULL')
										END
									+ ' (Forced roll back of all changes)'
			END
		ELSE
			BEGIN
				SET @MessageText    = 'Failed to write journal entry: '
									+ CASE
										WHEN LEN(@MessageText) > 475
											THEN '"' + SUBSTRING(@MessageText, 1, 475) + '..."'
										ELSE
											COALESCE('"' + @MessageText + '"', 'NULL')
										END
			END

		--! Record any failure info
		EXEC [log4].[ExceptionHandler]
				  @ErrorContext = @MessageText
				, @ErrorNumber  = @Error OUT
	END CATCH

--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	SET NOCOUNT OFF

	RETURN(@Error)

END
GO
PRINT N'Creating [log4Utils].[JournalCleanup]...';


GO

/*************************************************************************************************/
--</MaintenanceHeader>

CREATE PROCEDURE [log4Utils].[JournalCleanup]
(
  @DaysToKeepJournal            int
, @DaysToKeepException			int
)

AS

/**************************************************************************************************

Properties
==========
PROCEDURE NAME:		[log4Utils].[JournalCleanup]
DESCRIPTION:		Deletes all Journal and Exception entries older than the specified days
DATE OF ORIGIN:		16-FEB-2007
ORIGINAL AUTHOR:	Greg M. Lucas (data-centric solutions ltd. http://www.data-centric.co.uk)
BUILD DATE:			01-MAR-2015
BUILD VERSION:		0.0.13
DEPENDANTS:			None
DEPENDENCIES:		None

Inputs
======
@DatabaseName
@FunctionName
@MessageText
@StepInFunction
@ExtraInfo
@Severity

Outputs
=======
None

Returns
=======
@@ERROR - always zero on success

Additional Notes
================

Revision history
==================================================================================================
ChangeDate		Author	Version		Narrative
============	======	=======		==============================================================
16-FEB-2007		GML		v0.0.2		Created
------------	------	-------		--------------------------------------------------------------
29-AUG-2011		GML		v0.0.7		Added support for ExceptionId (now ensures that Exception
									deleted date is greater than Journa delete date)
------------	------	-------		--------------------------------------------------------------



=================================================================================================
(C) Copyright 2006-14 data-centric solutions ltd. (http://log4tsql.sourceforge.net/)

This library is free software; you can redistribute it and/or modify it under the terms of the
GNU Lesser General Public License as published by the Free Software Foundation (www.fsf.org);
either version 3.0 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with this
library; if not, you can find it at http://www.opensource.org/licenses/lgpl-3.0.html
or http://www.gnu.org/licenses/lgpl.html

**************************************************************************************************/

BEGIN
	SET NOCOUNT ON

	--! Standard/common variables
	DECLARE	  @_Error					int
			, @_RowCount				int
			, @_DatabaseName			nvarchar(128)
			, @_DebugMessage			varchar(2000)
			, @_SprocStartTime			datetime
			, @_StepStartTime			datetime

	--! WriteJournal variables
	DECLARE   @_FunctionName			varchar(256)
			, @_Message					varchar(512)
			, @_ProgressText			nvarchar(max)
			, @_Step					varchar(128)
			, @_Severity				smallint

	--! ExceptionHandler variables
	DECLARE   @_CustomErrorText			varchar(512)
			, @_ErrorMessage			varchar(4000)
			, @_ExceptionId				int

	--! Common Debug variables
	DECLARE	  @_LoopStartTime			datetime
			, @_StepEndTime				datetime
			, @_CRLF					char(1)

	--! Populate the common variables
	SET @_SprocStartTime	= GETDATE()
	SET @_FunctionName		= OBJECT_NAME(@@PROCID)
	SET @_DatabaseName		= DB_NAME()
	SET @_Error				= 0
	SET @_Severity			= 256 -- Informational
	SET @_CRLF				= CHAR(10)
	SET @_DebugMessage		= @_FunctionName + ' starting at ' + CONVERT(char(23), @_SprocStartTime, 121) + ' with inputs: '
							+ @_CRLF + '    @DaysToKeepJournal     : ' + COALESCE(CAST(@DaysToKeepJournal AS varchar(8)), 'NULL')
							+ @_CRLF + '    @DaysToKeepException   : ' + COALESCE(CAST(@DaysToKeepException AS varchar(8)), 'NULL')
	SET @_ProgressText		= @_DebugMessage

	--! Define our working values
	DECLARE @_DaysToKeepJournal		int;		SET @_DaysToKeepJournal = COALESCE(@DaysToKeepJournal, 30)
	DECLARE @_DaysToKeepException	int;		SET @_DaysToKeepException = COALESCE(@DaysToKeepException, @_DaysToKeepJournal + 1)
	DECLARE @_JournalArchiveDate	datetime;	SET @_JournalArchiveDate = CONVERT(char(11), DATEADD(day, - @_DaysToKeepJournal, GETDATE()), 113)
	DECLARE @_ExceptionArchiveDate	datetime;	SET @_ExceptionArchiveDate = CONVERT(char(11), DATEADD(day, - @_DaysToKeepException, GETDATE()), 113)

	SET @_ProgressText		= @_ProgressText
							+ @_CRLF + 'and working values...'
							+ @_CRLF + '    @_DaysToKeepJournal     : ' + COALESCE(CAST(@_DaysToKeepJournal AS varchar(8)), 'NULL')
							+ @_CRLF + '    @_DaysToKeepException   : ' + COALESCE(CAST(@_DaysToKeepException AS varchar(8)), 'NULL')
							+ @_CRLF + '    @_JournalArchiveDate   : ' + COALESCE(CONVERT(char(19), @_JournalArchiveDate, 120), 'NULL')
							+ @_CRLF + '    @_ExceptionArchiveDate : ' + COALESCE(CONVERT(char(19), @_ExceptionArchiveDate, 120), 'NULL')

	--!
	--!
	--!
	BEGIN TRY
		SET @_Step = 'Validate inputs';

		--!
		--! There is an FK between Journal and Exception so we can't delete more from Exception
		--! than we do from Journal
		--!
		IF @_JournalArchiveDate >= @_ExceptionArchiveDate
			BEGIN
				SET @_Message	= 'Failed to clean up Journal and Exception tables as Journal delete Date: '
								+ COALESCE(CONVERT(char(19), @_JournalArchiveDate, 120), 'NULL')
								+ ' must be less than Exception delete date: '
								+ COALESCE(CONVERT(char(19), @_ExceptionArchiveDate, 120), 'NULL')
				RAISERROR(@_Message, 16, 1);
			END

		SET @_Step = 'Delete old Journal entries';
		SET @_StepStartTime = GETDATE();

		BEGIN TRAN

		--! Don't need to DELETE JournalDetail as FK cascades
		DELETE
			[log4Private].[Journal]
		WHERE
			SystemDate < @_JournalArchiveDate

		SET @_RowCount		= @@ROWCOUNT;
		SET @_DebugMessage	= 'Completed step: "' +  COALESCE(@_Step, 'NULL') + '"'
							+ ' in ' + [log4].[FormatElapsedTime](@_StepStartTime, NULL, 3)
							+ ' ' + COALESCE(CAST(@_RowCount AS varchar(8)), 'NULL') + ' row(s) affected'
		SET @_ProgressText	= @_ProgressText + @_CRLF + @_DebugMessage

		IF  @@TRANCOUNT > 0 COMMIT TRAN
	END TRY
	BEGIN CATCH
		IF ABS(XACT_STATE()) = 1 OR @@TRANCOUNT > 0 ROLLBACK TRAN;

		SET @_CustomErrorText	= 'Failed to cleanup Journal and Exception at step: ' + COALESCE(@_Step, 'NULL')

		EXEC [log4].[ExceptionHandler]
				  @ErrorContext    = @_CustomErrorText
				, @ErrorProcedure  = @_FunctionName
				, @ErrorNumber     = @_Error OUT
				, @ReturnMessage   = @_Message OUT
				, @ExceptionId     = @_ExceptionId OUT

		GOTO OnComplete;
	END CATCH

	--!
	--!
	--!
	BEGIN TRY
		SET @_Step = 'Delete old Exception entries';
		SET @_StepStartTime = GETDATE();

		BEGIN TRAN

		DELETE
			[log4Private].[SqlException]
		WHERE
			SystemDate < @_ExceptionArchiveDate

		SET @_RowCount		= @@ROWCOUNT;
		SET @_DebugMessage	= 'Completed step: "' +  COALESCE(@_Step, 'NULL') + '"'
							+ ' in ' + [log4].[FormatElapsedTime](@_StepStartTime, NULL, 3)
							+ ' ' + COALESCE(CAST(@_RowCount AS varchar(8)), 'NULL') + ' row(s) affected'
		SET @_ProgressText	= @_ProgressText + @_CRLF + @_DebugMessage

		IF  @@TRANCOUNT > 0 COMMIT TRAN

		SET @_Message		= 'Completed all Journal and Exception cleanup activities;'
							+ ' retaining ' + COALESCE(CAST(@DaysToKeepJournal AS varchar(8)), 'NULL') + ' days'' Journal entries'
							+ ' and ' + COALESCE(CAST(@DaysToKeepException AS varchar(8)), 'NULL') + ' days'' Exception entries'
	END TRY
	BEGIN CATCH
		IF ABS(XACT_STATE()) = 1 OR @@TRANCOUNT > 0 ROLLBACK TRAN;

		SET @_CustomErrorText	= 'Failed to cleanup Journal and Exception at step: ' + COALESCE(@_Step, 'NULL')

		EXEC [log4].[ExceptionHandler]
				  @ErrorContext    = @_CustomErrorText
				, @ErrorProcedure  = @_FunctionName
				, @ErrorNumber     = @_Error OUT
				, @ReturnMessage   = @_Message OUT
				, @ExceptionId     = @_ExceptionId OUT

		GOTO OnComplete;
	END CATCH


--/////////////////////////////////////////////////////////////////////////////////////////////////
OnComplete:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	IF @_Error = 0
		BEGIN
			SET @_Step			= 'OnComplete'
			SET @_Severity		= 512 -- Success
			SET @_Message		= COALESCE(@_Message, @_Step) + ' in a total run time of ' + [log4].[FormatElapsedTime](@_SprocStartTime, NULL, 3)
		END
	ELSE
		BEGIN
			SET @_Step			= COALESCE(@_Step, 'OnError')
			SET @_Severity		= 2 -- Severe Failure
			SET @_Message		= COALESCE(@_Message, @_Step) + ' after a total run time of ' + [log4].[FormatElapsedTime](@_SprocStartTime, NULL, 3)
		END

	--! Always log completion of this call
	EXEC [log4].[JournalWriter]
			  @FunctionName		= @_FunctionName
			, @StepInFunction	= @_Step
			, @MessageText		= @_Message
			, @ExtraInfo		= @_ProgressText
			, @DatabaseName		= @_DatabaseName
			, @Severity			= @_Severity
			, @ExceptionId		= @_ExceptionId

	--! Finaly, throw an exception that will be detected by SQL Agent
	IF @_Error > 0 RAISERROR(@_Message, 16, 1);

	SET NOCOUNT OFF;

	RETURN (@_Error);
END
GO
PRINT N'Creating [privy].[InvoiceRefresh]...';


GO
create procedure [privy].[InvoiceRefresh]
(
  @LoadStart datetime
, @DebugLevel tinyint = 0
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.InvoiceRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		13-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		13-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Journal Constants
	declare @SEVERITY_CRITICAL int = 1;
	declare @SEVERITY_SEVERE int = 2;
	declare @SEVERITY_MAJOR int = 4;
	declare @SEVERITY_MODERATE int = 8;
	declare @SEVERITY_MINOR int = 16;
	declare @SEVERITY_CONCURRENCY int = 32;
	declare @SEVERITY_INFORMATION int = 256;
	declare @SEVERITY_SUCCESS int = 512;
	declare @SEVERITY_DEBUG int = 1024;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_RowCount int = 0;
	declare @_ReturnValue int = 0;
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_SprocStartTime datetime = getdate()
	declare	@_StepStartTime datetime
	declare	@_StepEndTime datetime
	declare	@_Step varchar(128);
	declare	@_ProgressMessage varchar(2000)
	declare	@_ExceptionId int
	declare @_JournalOnOff varchar(3) = log4.GetJournalControl(@_FunctionName, null);
	declare @_Severity smallint = @SEVERITY_INFORMATION;
	declare @_ProgressLog nvarchar(max);
	declare @_RowsAffected int = 0;
	declare @_JobName nvarchar(128) = 'QlikView Staging Data' ;

	set @_ProgressMessage = @_FunctionName
			+ ' starting at ' + coalesce(convert(varchar(24), @_SprocStartTime, 120), '') + ' with inputs: '
			+ char(10) + '    @LoadStart   : ' + coalesce(convert(varchar(24), @LoadStart, 120), '')
			+ char(10) + '    @DebugLevel      : ' + coalesce(cast(@DebugLevel as varchar(16)), 'NULL')
			+ char(10)
	set @_ProgressLog = @_ProgressMessage;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 5
	/**/     begin
	/**/         raiserror('', 0, 1) with nowait;
	/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
	/**/     end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--!
		--!
		--!
		set @_Step = 'Collect Load Parameters';
		set @_StepStartTime = getdate();

		declare @_ParameterSource varchar(200), @_DataCaptureStart datetime, @_DataCaptureEnd datetime;
		select
			  @_ParameterSource = ModuleName
			, @_DataCaptureStart = DataCaptureStart
			, @_DataCaptureEnd = DataCaptureEnd
		from
			privy.GetLoadParameters(@_FunctionName)

		set @_ProgressMessage = 'Load Parameter Values:'
				+ char(10) + '    Parameter Value Source  : ' + coalesce(@_ParameterSource, 'NULL')
				+ char(10) + '    Data Capture Start      : ' + coalesce(convert(varchar(24), @_DataCaptureStart, 120), '')
				+ char(10) + '    Data Capture End        : ' + coalesce(convert(varchar(24), @_DataCaptureEnd, 120), '')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to fetch load parameters'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		if @_DataCaptureStart is null
			raiserror('Load Parameter: Data Capture Start cannot be null', 16, 1);

		if @_DataCaptureStart is null
			raiserror('Load Parameter: Data Capture Start cannot be null', 16, 1);

		--!
		--!
		--!
		set @_Step = 'Collect Runtime Parameters';
		set @_StepStartTime = getdate();

		declare @_UnmappedPaymentTerm varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'PAYMENT_UNMAPPED') ;
		declare @_UnmappedProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SA_UNMAPPED_ITEM') ;
		declare @_ExcludeFromQlikViewProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SALES_NOT_QLIKVIEW') ;
		declare @_ExcludeFromQlikViewCustomerCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'CUSTOMER_NOT_EXPORTED') ;

		set @_ProgressMessage = 'Parameter Values:'
				+ char(10) + '    Unmapped Payment Term                    : ' + coalesce(@_UnmappedPaymentTerm, 'NULL')
				+ char(10) + '    Unmapped Product Category                : ' + coalesce(@_UnmappedProductCategory, 'NULL')
				+ char(10) + '    Exclude From QlikView Product Category   : ' + coalesce(@_ExcludeFromQlikViewProductCategory, 'NULL')
				+ char(10) + '    Exclude From QlikView Customer Category  : ' + coalesce(@_ExcludeFromQlikViewCustomerCategory, 'NULL')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to fetch runtime parameters'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = 'Generate Working Values';
		set @_StepStartTime = getdate();

		declare @_UnmappedPaymentTermId int ;
		if len(@_UnmappedPaymentTerm) > 0 and isnumeric(@_UnmappedPaymentTerm) = 1
			set @_UnmappedPaymentTermId = cast(@_UnmappedPaymentTerm as int)

		declare @_UnmappedProductCategoryId int ;
		if len(@_UnmappedProductCategory) > 0 and isnumeric(@_UnmappedProductCategory) = 1
			set @_UnmappedProductCategoryId = cast(@_UnmappedProductCategory as int)

		declare @_ExcludeFromQlikViewProductCategoryId int ;
		if len(@_ExcludeFromQlikViewProductCategory) > 0 and isnumeric(@_ExcludeFromQlikViewProductCategory) = 1
			set @_ExcludeFromQlikViewProductCategoryId = cast(@_ExcludeFromQlikViewProductCategory as int)
		else
			set @_ExcludeFromQlikViewProductCategoryId = -2 ;

		if @_ExcludeFromQlikViewProductCategoryId is null
			raiserror('Product Category Id to exclude from QlikView extract cannot be identified', 16, 1);

		declare @_ExcludeFromQlikViewCustomerCategoryId int ;
		if len(@_ExcludeFromQlikViewCustomerCategory) > 0 and isnumeric(@_ExcludeFromQlikViewCustomerCategory) = 1
			set @_ExcludeFromQlikViewCustomerCategoryId = cast(@_ExcludeFromQlikViewCustomerCategory as int)
		else
			set @_ExcludeFromQlikViewCustomerCategoryId = -2 ;

		if @_ExcludeFromQlikViewCustomerCategoryId is null
			raiserror('Customer Category Id to exclude from QlikView extract cannot be identified', 16, 1);

		set @_ProgressMessage = 'Working Values:'
				+ char(10) + '    Unmapped Payment Term Id                    : ' + coalesce(cast(@_UnmappedPaymentTermId as varchar(16)), 'NULL')
				+ char(10) + '    Unmapped Product Category Id                : ' + coalesce(cast(@_UnmappedProductCategoryId as varchar(16)), 'NULL')
				+ char(10) + '    Exclude From QlikView Product Category Id   : ' + coalesce(cast(@_ExcludeFromQlikViewProductCategoryId as varchar(16)), 'NULL')
				+ char(10) + '    Exclude From QlikView Customer Category Id  : ' + coalesce(cast(@_ExcludeFromQlikViewCustomerCategoryId as varchar(16)), 'NULL')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to generate working values'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'
		set @_StepStartTime = getdate();

		;with sourceCte
		as
		(
			--! The following columns are defined as NOT NULL on the underlying table: REC_ID, SYSTEM_ID, SITE_SOLD, INVOICE_NUMBER, INVOICE_LINE_NUMBER
			--! We use the following columns to uniquely identify each row: SYSTEM_ID, INVOICE_NUMBER, ORDER_NUMBER, INVOICE_LINE_NUMBER, ORDER_LINE_NUMBER, INVOICE_DATE, Uniqueifier
			select
				  inv.REC_ID
				, inv.SYSTEM_ID
				, inv.INVOICE_DATE
				, inv.INVOICE_NUMBER as [INVOICE_NUMBER]
				, inv.INVOICE_LINE_NUMBER as [INVOICE_LINE_NUMBER]
				, coalesce(inv.ORDER_NUMBER, '') as [ORDER_NUMBER]
				, coalesce(inv.ORDER_LINE_NUMBER, '') as [ORDER_LINE_NUMBER]
				, row_number() over (partition by inv.SYSTEM_ID, inv.INVOICE_NUMBER, inv.ORDER_NUMBER, inv.INVOICE_LINE_NUMBER, inv.ORDER_LINE_NUMBER order by inv.INVOICE_DATE desc, inv.REC_ID) as [Uniqueifier]
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(inv.INVOICE_TYPE, '') as [INVOICE_TYPE]
				, case coalesce(inv.INVOICE_TYPE, '')
					when '1' then 'TODO: Define Invoice Type (' + coalesce(inv.INVOICE_TYPE, '') + ')'
					when '2' then 'TODO: Define Invoice Type (' + coalesce(inv.INVOICE_TYPE, '') + ')'
					when '9' then 'TODO: Define Invoice Type (' + coalesce(inv.INVOICE_TYPE, '') + ')'
					when '' then 'Not Specified At Source'
					else 'Lookup Not Found (' + coalesce(inv.INVOICE_TYPE, '') + ')'
				  end as [InvoiceTypeName]
				-----------------------------------------------------------------------------------------------------------------------
				, inv.SITE_SOLD as [LOCAL_SITE_SOLD]
				, ssite.SITE_ID -- Don't need to collect SBU from this as per V_SA_INVOICE as we will expose SiteKey in the view later
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(inv.ITEM_NO, '') as [ITEM_NO]
				, coalesce(pCat.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as [ITEM_CATEGORY_ID]
				, EnvPcat.ENV_CATEGORY_ID
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(inv.SOLD_TO, '') as [SOLD_TO_CUSTOMER_NO]
				, coalesce(inv.SHIP_TO, '') as [SHIP_TO_CUSTOMER_NO]
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(inv.SALESPERSON_ID, '') as [SALESPERSON_ID]
				, coalesce(inv.SALESPERSON_NAME, '') as [SALESPERSON_NAME]
				-----------------------------------------------------------------------------------------------------------------------
				, inv.DELIVERY_DATE
				, inv.EXPECTED_PAYMENT_DATE
				, inv.ACTUAL_PAYMENT_DATE
				, coalesce(inv.DELIVERY_TERM, '') as [LOCAL_DELIVERY_TERM] -- probably unrelated to PU_DELIVERYTERM which is empty anyway
				, coalesce(inv.DELIVERY_TERM_TEXT, '') as [LOCAL_DELIVERY_TERM_TEXT]
				, coalesce(lpt.PAYMENTTERM_ID, @_UnmappedPaymentTermId) as [PAYMENT_TERM_ID]
				, coalesce(inv.PAYMENT_TERM, '') as [LOCAL_PAYMENT_TERM]
				, coalesce(inv.PAYMENT_TERM_TEXT, '') as [LOCAL_PAYMENT_TERM_TEXT]
				-----------------------------------------------------------------------------------------------------------------------
				, inv.INVOICE_QUANTITY
				, coalesce(inv.INVOICE_UOM, '') as [INVOICE_UOM]
				, inv.STATISTIC_QUANTITY
				, coalesce( inv.STATISTIC_UOM, '') as [STATISTIC_UOM]
				, inv.QUANTITY
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(inv.UOM, '') as [LOCAL_UOM]
				, coalesce(lUom.HARMONIZED_UOM, '') as [LOCAL_UOM_HARMONIZED]
				, lUom.FACTOR as [LOCAL_UOM_FACTOR]
				-----------------------------------------------------------------------------------------------------------------------
				, inv.INVOICE_AMOUNT
				, inv.LOCAL_AMOUNT
				, inv.GROUP_AMOUNT
				, coalesce(inv.INVOICE_CURRENCY, '') as [INVOICE_CURRENCY]
				, coalesce(inv.LOCAL_CURRENCY, '') as [LOCAL_CURRENCY]
				-----------------------------------------------------------------------------------------------------------------------
				, inv.LINE_DISCOUNT_AMOUNT
				, inv.INVOICE_DISCOUNT_AMOUNT
				, inv.LINE_BONUS_AMOUNT
				, inv.BONUS_SHARE_AMOUNT
				, inv.STD_COST
				, inv.STD_FREIGHT
				-----------------------------------------------------------------------------------------------------------------------
--				, coalesce(inv.MATERIAL_CHAR1, '') as [MATERIAL_CHAR1]
--				, inv.MATERIAL_CHAR1_VALUE
--				, coalesce(inv.MATERIAL_CHAR2, '') as [MATERIAL_CHAR2]
--				, inv.MATERIAL_CHAR2_VALUE
--				, coalesce(inv.MATERIAL_CHAR3, '') as [MATERIAL_CHAR3]
--				, inv.MATERIAL_CHAR3_VALUE
--				, coalesce(inv.MATERIAL_CHAR4, '') as [MATERIAL_CHAR4]
--				, inv.MATERIAL_CHAR4_VALUE
--				, coalesce(inv.MATERIAL_CHAR5, '') as [MATERIAL_CHAR5]
--				, inv.MATERIAL_CHAR5_VALUE
				---------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(convert(varchar(24), inv.INVOICE_DATE, 120), 'INVOICE_DATE')
						+ coalesce(inv.INVOICE_TYPE, 'INVOICE_TYPE')
						+ case coalesce(inv.INVOICE_TYPE, '')
							when '1' then 'TODO: Define Invoice Type (' + coalesce(inv.INVOICE_TYPE, '') + ')'
							when '2' then 'TODO: Define Invoice Type (' + coalesce(inv.INVOICE_TYPE, '') + ')'
							when '9' then 'TODO: Define Invoice Type (' + coalesce(inv.INVOICE_TYPE, '') + ')'
							when '' then 'Not Specified At Source'
							else 'Lookup Not Found (' + coalesce(inv.INVOICE_TYPE, '') + ')'
						  end
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(inv.SITE_SOLD, 'SITE_SOLD')
						+ coalesce(cast(ssite.SITE_ID as nvarchar(30)), 'SITE_ID') -- Don't need to collect SBU from this as per V_SA_INVOICE as we will expose SiteKey in the view later
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(inv.ITEM_NO, 'ITEM_NO')
						+ coalesce(cast(coalesce(pCat.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as varchar(30)), 'ITEM_CATEGORY_ID')
						+ coalesce(cast(EnvPcat.ENV_CATEGORY_ID as nvarchar(30)), 'ENV_CATEGORY_ID')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(inv.SOLD_TO, 'SOLD_TO')
						+ coalesce(inv.SHIP_TO, 'SHIP_TO')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(inv.SALESPERSON_ID, 'SALESPERSON_ID')
						+ coalesce(inv.SALESPERSON_NAME, 'SALESPERSON_NAME')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(convert(char(19), inv.DELIVERY_DATE, 120), 'DELIVERY_DATE')
						+ coalesce(convert(char(19), inv.EXPECTED_PAYMENT_DATE, 120), 'EXPECTED_PAYMENT_DATE')
						+ coalesce(convert(char(19), inv.ACTUAL_PAYMENT_DATE, 120), 'ACTUAL_PAYMENT_DATE')
						+ coalesce(inv.DELIVERY_TERM, 'DELIVERY_TERM')
						+ coalesce(inv.DELIVERY_TERM_TEXT, 'DELIVERY_TERM_TEXT')
						+ coalesce(cast(coalesce(lpt.PAYMENTTERM_ID, @_UnmappedPaymentTermId) as varchar(30)), 'PAYMENTTERM_ID')
						+ coalesce(inv.PAYMENT_TERM, 'PAYMENT_TERM')
						+ coalesce(inv.PAYMENT_TERM_TEXT, 'PAYMENT_TERM_TEXT')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(inv.INVOICE_QUANTITY as nvarchar(30)), 'INVOICE_QUANTITY')
						+ coalesce(inv.INVOICE_UOM, 'INVOICE_UOM') 
						+ coalesce(cast(inv.STATISTIC_QUANTITY as nvarchar(30)), 'STATISTIC_QUANTITY')
						+ coalesce( inv.STATISTIC_UOM, 'STATISTIC_UOM')
						+ coalesce(cast(inv.QUANTITY as nvarchar(30)), 'QUANTITY')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(inv.UOM, 'UOM')
						+ coalesce(lUom.HARMONIZED_UOM, 'HARMONIZED_UOM')
						+ coalesce(cast(lUom.FACTOR as nvarchar(30)), 'FACTOR')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(inv.INVOICE_AMOUNT as nvarchar(30)), 'INVOICE_AMOUNT')
						+ coalesce(cast(inv.LOCAL_AMOUNT as nvarchar(30)), 'LOCAL_AMOUNT')
						+ coalesce(cast(inv.GROUP_AMOUNT as nvarchar(30)), 'GROUP_AMOUNT')
						+ coalesce(inv.INVOICE_CURRENCY, 'INVOICE_CURRENCY')
						+ coalesce(inv.LOCAL_CURRENCY, 'LOCAL_CURRENCY')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(inv.LINE_DISCOUNT_AMOUNT as nvarchar(30)), 'LINE_DISCOUNT_AMOUNT')
						+ coalesce(cast(inv.INVOICE_DISCOUNT_AMOUNT as nvarchar(30)), 'INVOICE_DISCOUNT_AMOUNT')
						+ coalesce(cast(inv.LINE_BONUS_AMOUNT as nvarchar(30)), 'LINE_BONUS_AMOUNT')
						+ coalesce(cast(inv.BONUS_SHARE_AMOUNT as nvarchar(30)), 'BONUS_SHARE_AMOUNT')
						+ coalesce(cast(inv.STD_COST as nvarchar(30)), 'STD_COST')
						+ coalesce(cast(inv.STD_FREIGHT as nvarchar(30)), 'STD_FREIGHT')), 2) as [EtlDeltaHash]
						-----------------------------------------------------------------------------------------------------------------------
--						+ coalesce(inv.MATERIAL_CHAR1, 'MATERIAL_CHAR1')
--						+ coalesce(cast(inv.MATERIAL_CHAR1_VALUE as nvarchar(30)), 'MATERIAL_CHAR1_VALUE')
--						+ coalesce(inv.MATERIAL_CHAR2, 'MATERIAL_CHAR2')
--						+ coalesce(cast(inv.MATERIAL_CHAR2_VALUE as nvarchar(30)), 'MATERIAL_CHAR2_VALUE')
--						+ coalesce(inv.MATERIAL_CHAR3, 'MATERIAL_CHAR3')
--						+ coalesce(cast(inv.MATERIAL_CHAR3_VALUE as nvarchar(30)), 'MATERIAL_CHAR3_VALUE')
--						+ coalesce(inv.MATERIAL_CHAR4, 'MATERIAL_CHAR4')
--						+ coalesce(cast(inv.MATERIAL_CHAR4_VALUE as nvarchar(30)), 'MATERIAL_CHAR4_VALUE')
--						+ coalesce(inv.MATERIAL_CHAR5, 'MATERIAL_CHAR5')
--						+ coalesce(cast(inv.MATERIAL_CHAR5_VALUE as nvarchar(30)), 'MATERIAL_CHAR5_VALUE')), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].dbo.SA_INVOICE as inv
			inner join [$(Icopal_profBIS)].dbo.PU_LINK_SITE as ssite
				on ssite.SYSTEM_ID = inv.SYSTEM_ID
				and ssite.LOCAL_SITE = inv.SITE_SOLD
			inner join [$(Icopal_profBIS)].dbo.MD_SITE as msite
				on msite.SITE_ID = ssite.SITE_ID
			--! Make sure we can filter for just invoices belonging to SBUs where SABIS is true
			inner join [$(Icopal_profBIS)].dbo.MD_SBU as sbu
				on sbu.SBU   = msite.SBU
			left outer join [$(Icopal_profBIS)].dbo.PU_LINK_UOM as lUom
				on lUom.SYSTEM_ID = inv.SYSTEM_ID
				and lUom.LOCAL_UOM = inv.UOM
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_ITEM as pCat
				on pCat.SYSTEM_ID = inv.SYSTEM_ID
				and pCat.ITEM_NO = inv.ITEM_NO
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_ENV as EnvPcat
				on EnvPcat.SYSTEM_ID = inv.SYSTEM_ID
				and EnvPcat.ITEM_NO = inv.ITEM_NO
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_CUSTOMER as lcc 
				on lcc.SYSTEM_ID = inv.SYSTEM_ID
				and lcc.CUSTOMER_NO = inv.SHIP_TO
			left outer join [$(Icopal_profBIS)].dbo.PU_LINK_PAYMENTTERM as lpt
				on lpt.SYSTEM_ID = inv.SYSTEM_ID
				and lpt.PAYMENT_TERM = inv.PAYMENT_TERM
			where
					inv.INVOICE_DATE between @_DataCaptureStart and @_DataCaptureEnd
				--! Replicate all the filters used in Icopal_profBIS.dbo.V_SA_INVOICE (except date)
				and sbu.SABIS = 'Y'
				and inv.INVOICE_TYPE in ('1', '2', '9')
				and isnull(pCat.ITEM_CATEGORY_ID, -1) <> @_ExcludeFromQlikViewProductCategoryId
				and isnull(lcc.CUSTOMER_CATEGORY_ID, -1) <> @_ExcludeFromQlikViewCustomerCategoryId
--			and 
--				(
--						1 = 0
--					or (inv.SYSTEM_ID = 15 and inv.INVOICE_NUMBER = '3350489' and inv.INVOICE_LINE_NUMBER = '10' and inv.ITEM_NO = '102605') -- 20
--					or (inv.SYSTEM_ID = 15 and inv.INVOICE_NUMBER = '3150707' and inv.INVOICE_LINE_NUMBER = '10'and inv.ITEM_NO = '102605') -- 14
--					or (inv.SYSTEM_ID = 12 and inv.INVOICE_NUMBER = '170997' and inv.INVOICE_LINE_NUMBER = '1' and inv.ITEM_NO = '42820') -- 6
--					or (inv.SYSTEM_ID = 12 and inv.INVOICE_NUMBER = '170997' and inv.INVOICE_LINE_NUMBER = '10' and inv.ITEM_NO = '71170') -- 6
--					or (inv.SYSTEM_ID = 12 and inv.INVOICE_NUMBER = '170997' and inv.INVOICE_LINE_NUMBER = '2' and inv.ITEM_NO = '71150') -- 6
--					or (inv.SYSTEM_ID = 2 and inv.INVOICE_NUMBER = '001308113' and inv.INVOICE_LINE_NUMBER = '030' and inv.ITEM_NO = '23264')
--					or (inv.SYSTEM_ID = 2 and inv.INVOICE_NUMBER = '001505511' and inv.INVOICE_LINE_NUMBER = '005' and inv.ITEM_NO = '11092') -- 5
--					or (inv.SYSTEM_ID = 2 and inv.INVOICE_NUMBER = '001505511' and inv.INVOICE_LINE_NUMBER = '010' and inv.ITEM_NO = '11094') -- 5
--					or (inv.SYSTEM_ID = 2 and inv.INVOICE_NUMBER = '001505511' and inv.INVOICE_LINE_NUMBER = '015' and inv.ITEM_NO = '16282') -- 5
--					or (inv.SYSTEM_ID = 2 and inv.INVOICE_NUMBER = '001600622' and inv.INVOICE_LINE_NUMBER = '005' and inv.ITEM_NO = '22604') -- 5
--					or (inv.SYSTEM_ID = 2 and inv.INVOICE_NUMBER = '001308113' and inv.INVOICE_LINE_NUMBER = '030' and inv.ITEM_NO = '23264') -- 4
--					or (inv.SYSTEM_ID = 1 and inv.INVOICE_NUMBER = '0090748418' and inv.INVOICE_LINE_NUMBER = '000010' and inv.ITEM_NO = 'REBATE') -- 4
--					or (inv.SYSTEM_ID = 1 and inv.INVOICE_NUMBER = '0090751546' and inv.INVOICE_LINE_NUMBER = '000010' and inv.ITEM_NO = '3100407') -- 4
--					or (inv.SYSTEM_ID = 1 and inv.INVOICE_NUMBER = '0090751546' and inv.INVOICE_LINE_NUMBER = '000020' and inv.ITEM_NO = '3007163') -- 4
--				)
		)
		merge into stg.Invoice as tgt
		using sourceCte as src
			on src.SYSTEM_ID = tgt.SYSTEM_ID
			and src.INVOICE_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.INVOICE_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.ORDER_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.ORDER_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.INVOICE_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.INVOICE_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.ORDER_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.ORDER_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.Uniqueifier = tgt.Uniqueifier
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, REC_ID
			, SYSTEM_ID
			, INVOICE_DATE
			, INVOICE_NUMBER
			, INVOICE_LINE_NUMBER
			, ORDER_NUMBER
			, ORDER_LINE_NUMBER
			, Uniqueifier
			, INVOICE_TYPE
			, InvoiceTypeName
			, LOCAL_SITE_SOLD
			, SITE_ID
			, ITEM_NO
			, ITEM_CATEGORY_ID
			, ENV_CATEGORY_ID
			, SOLD_TO_CUSTOMER_NO
			, SHIP_TO_CUSTOMER_NO
			, SALESPERSON_ID
			, SALESPERSON_NAME
			, DELIVERY_DATE
			, EXPECTED_PAYMENT_DATE
			, ACTUAL_PAYMENT_DATE
			, LOCAL_DELIVERY_TERM
			, LOCAL_DELIVERY_TERM_TEXT
			, PAYMENT_TERM_ID
			, LOCAL_PAYMENT_TERM
			, LOCAL_PAYMENT_TERM_TEXT
			, INVOICE_QUANTITY
			, INVOICE_UOM
			, STATISTIC_QUANTITY
			, STATISTIC_UOM
			, QUANTITY
			, LOCAL_UOM
			, LOCAL_UOM_HARMONIZED
			, LOCAL_UOM_FACTOR
			, INVOICE_AMOUNT
			, LOCAL_AMOUNT
			, GROUP_AMOUNT
			, INVOICE_CURRENCY
			, LOCAL_CURRENCY
			, LINE_DISCOUNT_AMOUNT
			, INVOICE_DISCOUNT_AMOUNT
			, LINE_BONUS_AMOUNT
			, BONUS_SHARE_AMOUNT
			, STD_COST
			, STD_FREIGHT
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.REC_ID
			, src.SYSTEM_ID
			, src.INVOICE_DATE
			, src.INVOICE_NUMBER
			, src.INVOICE_LINE_NUMBER
			, src.ORDER_NUMBER
			, src.ORDER_LINE_NUMBER
			, src.Uniqueifier
			, src.INVOICE_TYPE
			, src.InvoiceTypeName
			, src.LOCAL_SITE_SOLD
			, src.SITE_ID
			, src.ITEM_NO
			, src.ITEM_CATEGORY_ID
			, src.ENV_CATEGORY_ID
			, src.SOLD_TO_CUSTOMER_NO
			, src.SHIP_TO_CUSTOMER_NO
			, src.SALESPERSON_ID
			, src.SALESPERSON_NAME
			, src.DELIVERY_DATE
			, src.EXPECTED_PAYMENT_DATE
			, src.ACTUAL_PAYMENT_DATE
			, src.LOCAL_DELIVERY_TERM
			, src.LOCAL_DELIVERY_TERM_TEXT
			, src.PAYMENT_TERM_ID
			, src.LOCAL_PAYMENT_TERM
			, src.LOCAL_PAYMENT_TERM_TEXT
			, src.INVOICE_QUANTITY
			, src.INVOICE_UOM
			, src.STATISTIC_QUANTITY
			, src.STATISTIC_UOM
			, src.QUANTITY
			, src.LOCAL_UOM
			, src.LOCAL_UOM_HARMONIZED
			, src.LOCAL_UOM_FACTOR
			, src.INVOICE_AMOUNT
			, src.LOCAL_AMOUNT
			, src.GROUP_AMOUNT
			, src.INVOICE_CURRENCY
			, src.LOCAL_CURRENCY
			, src.LINE_DISCOUNT_AMOUNT
			, src.INVOICE_DISCOUNT_AMOUNT
			, src.LINE_BONUS_AMOUNT
			, src.BONUS_SHARE_AMOUNT
			, src.STD_COST
			, src.STD_FREIGHT
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.REC_ID = src.REC_ID
					, tgt.INVOICE_TYPE = src.INVOICE_TYPE
					, tgt.InvoiceTypeName = src.InvoiceTypeName
					, tgt.LOCAL_SITE_SOLD = src.LOCAL_SITE_SOLD
					, tgt.SITE_ID = src.SITE_ID
					, tgt.ITEM_NO = src.ITEM_NO
					, tgt.ITEM_CATEGORY_ID = src.ITEM_CATEGORY_ID
					, tgt.ENV_CATEGORY_ID = src.ENV_CATEGORY_ID
					, tgt.SOLD_TO_CUSTOMER_NO = src.SOLD_TO_CUSTOMER_NO
					, tgt.SHIP_TO_CUSTOMER_NO = src.SHIP_TO_CUSTOMER_NO
					, tgt.SALESPERSON_ID = src.SALESPERSON_ID
					, tgt.SALESPERSON_NAME = src.SALESPERSON_NAME
					, tgt.DELIVERY_DATE = src.DELIVERY_DATE
					, tgt.EXPECTED_PAYMENT_DATE = src.EXPECTED_PAYMENT_DATE
					, tgt.ACTUAL_PAYMENT_DATE = src.ACTUAL_PAYMENT_DATE
					, tgt.LOCAL_DELIVERY_TERM = src.LOCAL_DELIVERY_TERM
					, tgt.LOCAL_DELIVERY_TERM_TEXT = src.LOCAL_DELIVERY_TERM_TEXT
					, tgt.PAYMENT_TERM_ID = src.PAYMENT_TERM_ID
					, tgt.LOCAL_PAYMENT_TERM = src.LOCAL_PAYMENT_TERM
					, tgt.LOCAL_PAYMENT_TERM_TEXT = src.LOCAL_PAYMENT_TERM_TEXT
					, tgt.INVOICE_QUANTITY = src.INVOICE_QUANTITY
					, tgt.INVOICE_UOM = src.INVOICE_UOM
					, tgt.STATISTIC_QUANTITY = src.STATISTIC_QUANTITY
					, tgt.STATISTIC_UOM = src.STATISTIC_UOM
					, tgt.QUANTITY = src.QUANTITY
					, tgt.LOCAL_UOM = src.LOCAL_UOM
					, tgt.LOCAL_UOM_HARMONIZED = src.LOCAL_UOM_HARMONIZED
					, tgt.LOCAL_UOM_FACTOR = src.LOCAL_UOM_FACTOR
					, tgt.INVOICE_AMOUNT = src.INVOICE_AMOUNT
					, tgt.LOCAL_AMOUNT = src.LOCAL_AMOUNT
					, tgt.GROUP_AMOUNT = src.GROUP_AMOUNT
					, tgt.INVOICE_CURRENCY = src.INVOICE_CURRENCY
					, tgt.LOCAL_CURRENCY = src.LOCAL_CURRENCY
					, tgt.LINE_DISCOUNT_AMOUNT = src.LINE_DISCOUNT_AMOUNT
					, tgt.INVOICE_DISCOUNT_AMOUNT = src.INVOICE_DISCOUNT_AMOUNT
					, tgt.LINE_BONUS_AMOUNT = src.LINE_BONUS_AMOUNT
					, tgt.BONUS_SHARE_AMOUNT = src.BONUS_SHARE_AMOUNT
					, tgt.STD_COST = src.STD_COST
					, tgt.STD_FREIGHT = src.STD_FREIGHT
		when not matched by source and (tgt.INVOICE_DATE between @_DataCaptureStart and @_DataCaptureEnd) and tgt.InvoiceKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;
		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@RowsAffected as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;

		--!
		--! If we get here, every step completed successfully so report final state
		--!
		set @_Message = 'Completed all staging data preparation steps'
		set @_Error = 0 ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh Invoice dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out
				, @ExceptionId    = @_ExceptionId out
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	if @_Error = 0
		begin
			set @_Step = 'OnComplete'
			set @_Severity = @SEVERITY_SUCCESS
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end
	else
		begin
			set @_Step = coalesce(@_Step, 'OnError')
			set @_Severity = @SEVERITY_SEVERE
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end

	if @DebugLevel != 0 and @_Severity = @SEVERITY_INFORMATION set @_Severity = @SEVERITY_DEBUG;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 4
	/**/	begin
	/**/		raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_Message) with nowait;
	/**/		raiserror('', 0, 1) with nowait;
	/**/	end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	if @_JournalOnOff = 'ON'
		exec log4.JournalWriter
				  @Task = @_JobName
				, @FunctionName = @_FunctionName
				, @StepInFunction = @_Step
				, @MessageText = @_Message
				, @ExtraInfo = @_ProgressLog
				, @Severity = @_Severity
				, @ExceptionId = @_ExceptionId

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[OrderShippedNotInvoicedRefresh]...';


GO
create procedure [privy].[OrderShippedNotInvoicedRefresh]
(
  @LoadStart datetime
, @DebugLevel tinyint = 0
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.OrderShippedNotInvoicedRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		14-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		14-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>
begin
	set nocount on;

	--! Journal Constants
	declare @SEVERITY_CRITICAL int = 1;
	declare @SEVERITY_SEVERE int = 2;
	declare @SEVERITY_MAJOR int = 4;
	declare @SEVERITY_MODERATE int = 8;
	declare @SEVERITY_MINOR int = 16;
	declare @SEVERITY_CONCURRENCY int = 32;
	declare @SEVERITY_INFORMATION int = 256;
	declare @SEVERITY_SUCCESS int = 512;
	declare @SEVERITY_DEBUG int = 1024;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_RowCount int = 0;
	declare @_ReturnValue int = 0;
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_SprocStartTime datetime = getdate()
	declare	@_StepStartTime datetime
	declare	@_StepEndTime datetime
	declare	@_Step varchar(128);
	declare	@_ProgressMessage varchar(2000)
	declare	@_ExceptionId int
	declare @_JournalOnOff varchar(3) = log4.GetJournalControl(@_FunctionName, null);
	declare @_Severity smallint = @SEVERITY_INFORMATION;
	declare @_ProgressLog nvarchar(max);
	declare @_RowsAffected int = 0;
	declare @_JobName nvarchar(128) = 'QlikView Staging Data' ;

	set @_ProgressMessage = @_FunctionName
			+ ' starting at ' + coalesce(convert(varchar(24), @_SprocStartTime, 120), '') + ' with inputs: '
			+ char(10) + '    @LoadStart   : ' + coalesce(convert(varchar(24), @LoadStart, 120), '')
			+ char(10) + '    @DebugLevel      : ' + coalesce(cast(@DebugLevel as varchar(16)), 'NULL')
			+ char(10)
	set @_ProgressLog = @_ProgressMessage;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 5
	/**/     begin
	/**/         raiserror('', 0, 1) with nowait;
	/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
	/**/     end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--!
		--!
		--!
		set @_Step = 'Collect Load Parameters';
		set @_StepStartTime = getdate();

		declare @_ParameterSource varchar(200), @_DataCaptureStart datetime, @_DataCaptureEnd datetime;
		select
			  @_ParameterSource = ModuleName
			, @_DataCaptureStart = DataCaptureStart
			, @_DataCaptureEnd = DataCaptureEnd
		from
			privy.GetLoadParameters(@_FunctionName)

		set @_ProgressMessage = 'Load Parameter Values:'
				+ char(10) + '    Parameter Value Source  : ' + coalesce(@_ParameterSource, 'NULL')
				+ char(10) + '    Data Capture Start      : ' + coalesce(convert(varchar(24), @_DataCaptureStart, 120), '')
				+ char(10) + '    Data Capture End        : ' + coalesce(convert(varchar(24), @_DataCaptureEnd, 120), '')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to fetch load parameters'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		if @_DataCaptureStart is null
			raiserror('Load Parameter: Data Capture Start cannot be null', 16, 1);

		if @_DataCaptureStart is null
			raiserror('Load Parameter: Data Capture Start cannot be null', 16, 1);

		--!
		--!
		--!
		set @_Step = 'Collect Runtime Parameters';
		set @_StepStartTime = getdate();

		declare @_UnmappedPaymentTerm varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'PAYMENT_UNMAPPED') ;
		declare @_UnmappedProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SA_UNMAPPED_ITEM') ;
		declare @_ExcludeFromQlikViewProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SALES_NOT_QLIKVIEW') ;
		declare @_ExcludeFromQlikViewCustomerCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'CUSTOMER_NOT_EXPORTED') ;

		set @_ProgressMessage = 'Parameter Values:'
				+ char(10) + '    Unmapped Payment Term                    : ' + coalesce(@_UnmappedPaymentTerm, 'NULL')
				+ char(10) + '    Unmapped Product Category                : ' + coalesce(@_UnmappedProductCategory, 'NULL')
				+ char(10) + '    Exclude From QlikView Product Category   : ' + coalesce(@_ExcludeFromQlikViewProductCategory, 'NULL')
				+ char(10) + '    Exclude From QlikView Customer Category  : ' + coalesce(@_ExcludeFromQlikViewCustomerCategory, 'NULL')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to fetch runtime parameters'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = 'Generate Working Values';
		set @_StepStartTime = getdate();

		declare @_UnmappedPaymentTermId int ;
		if len(@_UnmappedPaymentTerm) > 0 and isnumeric(@_UnmappedPaymentTerm) = 1
			set @_UnmappedPaymentTermId = cast(@_UnmappedPaymentTerm as int)

		declare @_UnmappedProductCategoryId int ;
		if len(@_UnmappedProductCategory) > 0 and isnumeric(@_UnmappedProductCategory) = 1
			set @_UnmappedProductCategoryId = cast(@_UnmappedProductCategory as int)

		declare @_ExcludeFromQlikViewProductCategoryId int ;
		if len(@_ExcludeFromQlikViewProductCategory) > 0 and isnumeric(@_ExcludeFromQlikViewProductCategory) = 1
			set @_ExcludeFromQlikViewProductCategoryId = cast(@_ExcludeFromQlikViewProductCategory as int)
		else
			set @_ExcludeFromQlikViewProductCategoryId = -2 ;

		if @_ExcludeFromQlikViewProductCategoryId is null
			raiserror('Product Category Id to exclude from QlikView extract cannot be identified', 16, 1);

		declare @_ExcludeFromQlikViewCustomerCategoryId int ;
		if len(@_ExcludeFromQlikViewCustomerCategory) > 0 and isnumeric(@_ExcludeFromQlikViewCustomerCategory) = 1
			set @_ExcludeFromQlikViewCustomerCategoryId = cast(@_ExcludeFromQlikViewCustomerCategory as int)
		else
			set @_ExcludeFromQlikViewCustomerCategoryId = -2 ;

		if @_ExcludeFromQlikViewCustomerCategoryId is null
			raiserror('Customer Category Id to exclude from QlikView extract cannot be identified', 16, 1);

		set @_ProgressMessage = 'Working Values:'
				+ char(10) + '    Unmapped Payment Term Id                    : ' + coalesce(cast(@_UnmappedPaymentTermId as varchar(16)), 'NULL')
				+ char(10) + '    Unmapped Product Category Id                : ' + coalesce(cast(@_UnmappedProductCategoryId as varchar(16)), 'NULL')
				+ char(10) + '    Exclude From QlikView Product Category Id   : ' + coalesce(cast(@_ExcludeFromQlikViewProductCategoryId as varchar(16)), 'NULL')
				+ char(10) + '    Exclude From QlikView Customer Category Id  : ' + coalesce(cast(@_ExcludeFromQlikViewCustomerCategoryId as varchar(16)), 'NULL')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to generate working values'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'
		set @_StepStartTime = getdate();

		;with sourceCte
		as
		(
			--! The following columns are defined as NOT NULL on the underlying table: REC_ID, SYSTEM_ID, SITE_SOLD
			--! We use the following columns to uniquely identify each row: SYSTEM_ID, ORDER_NUMBER, ORDER_LINE_NUMBER, SHIPPING_DOCUMENT and Uniqueifier
			select
				  ord.REC_ID
				, ord.SYSTEM_ID
				, coalesce(ord.ORDER_NUMBER, '') as [ORDER_NUMBER]
				, coalesce(ord.ORDER_LINE_NUMBER, '') as [ORDER_LINE_NUMBER]
				, coalesce(ord.SHIPPING_DOCUMENT, '') as [SHIPPING_DOCUMENT]
				, row_number() over (partition by ord.SYSTEM_ID, ord.ORDER_NUMBER, ord.ORDER_LINE_NUMBER, ord.SHIPPING_DOCUMENT order by ord.EXPECTED_INVOICE_DATE desc, ord.REC_ID) as [Uniqueifier]
				, ord.EXPECTED_INVOICE_DATE
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.ORDER_TYPE, '') as [ORDER_TYPE]
				, case coalesce(ord.ORDER_TYPE, '')
					when '1' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
					when '2' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
					when '' then 'Not Specified At Source'
					else 'Lookup Not Found (' + coalesce(ord.ORDER_TYPE, '') + ')'
				  end as [OrderTypeName]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.SITE_SOLD as [LOCAL_SITE_SOLD]
				, ssite.SITE_ID -- Don't need to collect SBU from this as per V_SA_ORDERSNI as we will expose SiteKey in the view later
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.ITEM_NO, '') as [ITEM_NO]
				, coalesce(pCat.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as [ITEM_CATEGORY_ID]
				, EnvPcat.ENV_CATEGORY_ID
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.SOLD_TO, '') as [SOLD_TO_CUSTOMER_NO]
				, coalesce(ord.SHIP_TO, '') as [SHIP_TO_CUSTOMER_NO]
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.SALESPERSON_ID, '') as [SALESPERSON_ID]
				, coalesce(ord.SALESPERSON_NAME, '') as [SALESPERSON_NAME]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.SHIPPED_QUANTITY
				, coalesce(ord.SHIPPED_UOM, '') as [SHIPPED_UOM]
				, ord.STATISTIC_QUANTITY
				, coalesce(ord.STATISTIC_UOM, '') as [STATISTIC_UOM]
				, ord.QUANTITY
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.UOM, '') as [LOCAL_UOM]
				, coalesce(lUom.HARMONIZED_UOM, '') as [LOCAL_UOM_HARMONIZED]
				, lUom.FACTOR as [LOCAL_UOM_FACTOR]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.SHIPPED_AMOUNT
				, ord.LOCAL_AMOUNT
				, ord.GROUP_AMOUNT
				, coalesce(ord.SHIPPED_CURRENCY, '') as [SHIPPED_CURRENCY]
				, coalesce(ord.LOCAL_CURRENCY, '') as [LOCAL_CURRENCY]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.LINE_DISCOUNT_AMOUNT
				, ord.ORDER_DISCOUNT_AMOUNT
				, ord.LINE_BONUS_AMOUNT
				, ord.BONUS_SHARE_AMOUNT
				-----------------------------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(convert(varchar(24), ord.EXPECTED_INVOICE_DATE, 120), 'EXPECTED_INVOICE_DATE')
						+ coalesce(ord.ORDER_TYPE, 'ORDER_TYPE')
						+ case coalesce(ord.ORDER_TYPE, '')
							when '1' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
							when '2' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
							when '' then 'Not Specified At Source'
							else 'Lookup Not Found (' + coalesce(ord.ORDER_TYPE, '') + ')'
						  end
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.SITE_SOLD, 'SITE_SOLD')
						+ coalesce(cast(ssite.SITE_ID as nvarchar(30)), 'SITE_ID') -- Don't need to collect SBU from this as per V_SA_INVOICE as we will expose SiteKey in the view later
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.ITEM_NO, 'ITEM_NO')
						+ coalesce(cast(coalesce(pCat.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as varchar(30)), 'ITEM_CATEGORY_ID')
						+ coalesce(cast(EnvPcat.ENV_CATEGORY_ID as nvarchar(30)), 'ENV_CATEGORY_ID')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.SOLD_TO, 'SOLD_TO')
						+ coalesce(ord.SHIP_TO, 'SHIP_TO')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.SALESPERSON_ID, 'SALESPERSON_ID')
						+ coalesce(ord.SALESPERSON_NAME, 'SALESPERSON_NAME')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(ord.SHIPPED_QUANTITY as nvarchar(30)), 'SHIPPED_QUANTITY')
						+ coalesce(ord.SHIPPED_UOM, 'SHIPPED_UOM') 
						+ coalesce(cast(ord.STATISTIC_QUANTITY as nvarchar(30)), 'STATISTIC_QUANTITY')
						+ coalesce( ord.STATISTIC_UOM, 'STATISTIC_UOM')
						+ coalesce(cast(ord.QUANTITY as nvarchar(30)), 'QUANTITY')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.UOM, 'UOM')
						+ coalesce(lUom.HARMONIZED_UOM, 'HARMONIZED_UOM')
						+ coalesce(cast(lUom.FACTOR as nvarchar(30)), 'FACTOR')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(ord.SHIPPED_AMOUNT as nvarchar(30)), 'SHIPPED_AMOUNT')
						+ coalesce(cast(ord.LOCAL_AMOUNT as nvarchar(30)), 'LOCAL_AMOUNT')
						+ coalesce(cast(ord.GROUP_AMOUNT as nvarchar(30)), 'GROUP_AMOUNT')
						+ coalesce(ord.SHIPPED_CURRENCY, 'SHIPPED_CURRENCY')
						+ coalesce(ord.LOCAL_CURRENCY, 'LOCAL_CURRENCY')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(ord.LINE_DISCOUNT_AMOUNT as nvarchar(30)), 'LINE_DISCOUNT_AMOUNT')
						+ coalesce(cast(ord.ORDER_DISCOUNT_AMOUNT as nvarchar(30)), 'ORDER_DISCOUNT_AMOUNT')
						+ coalesce(cast(ord.LINE_BONUS_AMOUNT as nvarchar(30)), 'LINE_BONUS_AMOUNT')
						+ coalesce(cast(ord.BONUS_SHARE_AMOUNT as nvarchar(30)), 'BONUS_SHARE_AMOUNT')), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].dbo.SA_ORDER_SNI as ord
			inner join [$(Icopal_profBIS)].dbo.PU_LINK_SITE as ssite
				on ssite.SYSTEM_ID = ord.SYSTEM_ID
				and ssite.LOCAL_SITE = ord.SITE_SOLD
			inner join [$(Icopal_profBIS)].dbo.MD_SITE as msite
				on msite.SITE_ID = ssite.SITE_ID
			--! Make sure we can filter for just invoices belonging to SBUs where SABIS is true
			inner join [$(Icopal_profBIS)].dbo.MD_SBU as sbu
				on sbu.SBU   = msite.SBU
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_ITEM as pCat
				on pCat.SYSTEM_ID = ord.SYSTEM_ID
				and pCat.ITEM_NO = ord.ITEM_NO
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_ENV as EnvPcat
				on EnvPcat.SYSTEM_ID = ord.SYSTEM_ID
				and EnvPcat.ITEM_NO = ord.ITEM_NO
			left outer join [$(Icopal_profBIS)].dbo.PU_LINK_UOM as lUom
				on lUom.SYSTEM_ID = ord.SYSTEM_ID
				and lUom.LOCAL_UOM = ord.UOM
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_CUSTOMER as lcc 
				on lcc.SYSTEM_ID = ord.SYSTEM_ID
				and lcc.CUSTOMER_NO = ord.SHIP_TO
			where
					ord.EXPECTED_INVOICE_DATE between @_DataCaptureStart and @_DataCaptureEnd
				--! Replicate all the filters used in Icopal_profBIS.dbo.V_SA_INVOICE (except date)
				and sbu.SABIS = 'Y'
				and ord.ORDER_TYPE in ('1', '2')
				and isnull(pCat.ITEM_CATEGORY_ID, -1) <> @_ExcludeFromQlikViewProductCategoryId
				and isnull(lcc.CUSTOMER_CATEGORY_ID, -1) <> @_ExcludeFromQlikViewCustomerCategoryId
		)
		merge into stg.OrderShippedNotInvoiced as tgt
		using sourceCte as src
			on src.SYSTEM_ID = tgt.SYSTEM_ID
			and src.ORDER_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.ORDER_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.ORDER_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.ORDER_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.SHIPPING_DOCUMENT collate SQL_Latin1_General_CP1_CI_AS = tgt.SHIPPING_DOCUMENT collate SQL_Latin1_General_CP1_CI_AS
			and src.Uniqueifier = tgt.Uniqueifier
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, REC_ID
			, SYSTEM_ID
			, ORDER_NUMBER
			, ORDER_LINE_NUMBER
			, SHIPPING_DOCUMENT
			, Uniqueifier
			, EXPECTED_INVOICE_DATE
			, ORDER_TYPE
			, OrderTypeName
			, LOCAL_SITE_SOLD
			, SITE_ID
			, ITEM_NO
			, ITEM_CATEGORY_ID
			, ENV_CATEGORY_ID
			, SOLD_TO_CUSTOMER_NO
			, SHIP_TO_CUSTOMER_NO
			, SALESPERSON_ID
			, SALESPERSON_NAME
			, SHIPPED_QUANTITY
			, SHIPPED_UOM
			, STATISTIC_QUANTITY
			, STATISTIC_UOM
			, QUANTITY
			, LOCAL_UOM
			, LOCAL_UOM_HARMONIZED
			, LOCAL_UOM_FACTOR
			, SHIPPED_AMOUNT
			, LOCAL_AMOUNT
			, GROUP_AMOUNT
			, SHIPPED_CURRENCY
			, LOCAL_CURRENCY
			, LINE_DISCOUNT_AMOUNT
			, ORDER_DISCOUNT_AMOUNT
			, LINE_BONUS_AMOUNT
			, BONUS_SHARE_AMOUNT
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.REC_ID
			, src.SYSTEM_ID
			, src.ORDER_NUMBER
			, src.ORDER_LINE_NUMBER
			, src.SHIPPING_DOCUMENT
			, src.Uniqueifier
			, src.EXPECTED_INVOICE_DATE
			, src.ORDER_TYPE
			, src.OrderTypeName
			, src.LOCAL_SITE_SOLD
			, src.SITE_ID
			, src.ITEM_NO
			, src.ITEM_CATEGORY_ID
			, src.ENV_CATEGORY_ID
			, src.SOLD_TO_CUSTOMER_NO
			, src.SHIP_TO_CUSTOMER_NO
			, src.SALESPERSON_ID
			, src.SALESPERSON_NAME
			, src.SHIPPED_QUANTITY
			, src.SHIPPED_UOM
			, src.STATISTIC_QUANTITY
			, src.STATISTIC_UOM
			, src.QUANTITY
			, src.LOCAL_UOM
			, src.LOCAL_UOM_HARMONIZED
			, src.LOCAL_UOM_FACTOR
			, src.SHIPPED_AMOUNT
			, src.LOCAL_AMOUNT
			, src.GROUP_AMOUNT
			, src.SHIPPED_CURRENCY
			, src.LOCAL_CURRENCY
			, src.LINE_DISCOUNT_AMOUNT
			, src.ORDER_DISCOUNT_AMOUNT
			, src.LINE_BONUS_AMOUNT
			, src.BONUS_SHARE_AMOUNT
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.REC_ID = src.REC_ID
					, tgt.EXPECTED_INVOICE_DATE = src.EXPECTED_INVOICE_DATE
					, tgt.ORDER_TYPE = src.ORDER_TYPE
					, tgt.OrderTypeName = src.OrderTypeName
					, tgt.LOCAL_SITE_SOLD = src.LOCAL_SITE_SOLD
					, tgt.SITE_ID = src.SITE_ID
					, tgt.ITEM_NO = src.ITEM_NO
					, tgt.ITEM_CATEGORY_ID = src.ITEM_CATEGORY_ID
					, tgt.ENV_CATEGORY_ID = src.ENV_CATEGORY_ID
					, tgt.SOLD_TO_CUSTOMER_NO = src.SOLD_TO_CUSTOMER_NO
					, tgt.SHIP_TO_CUSTOMER_NO = src.SHIP_TO_CUSTOMER_NO
					, tgt.SALESPERSON_ID = src.SALESPERSON_ID
					, tgt.SALESPERSON_NAME = src.SALESPERSON_NAME
					, tgt.SHIPPED_QUANTITY = src.SHIPPED_QUANTITY
					, tgt.SHIPPED_UOM = src.SHIPPED_UOM
					, tgt.STATISTIC_QUANTITY = src.STATISTIC_QUANTITY
					, tgt.STATISTIC_UOM = src.STATISTIC_UOM
					, tgt.QUANTITY = src.QUANTITY
					, tgt.LOCAL_UOM = src.LOCAL_UOM
					, tgt.LOCAL_UOM_HARMONIZED = src.LOCAL_UOM_HARMONIZED
					, tgt.LOCAL_UOM_FACTOR = src.LOCAL_UOM_FACTOR
					, tgt.SHIPPED_AMOUNT = src.SHIPPED_AMOUNT
					, tgt.LOCAL_AMOUNT = src.LOCAL_AMOUNT
					, tgt.GROUP_AMOUNT = src.GROUP_AMOUNT
					, tgt.SHIPPED_CURRENCY = src.SHIPPED_CURRENCY
					, tgt.LOCAL_CURRENCY = src.LOCAL_CURRENCY
					, tgt.LINE_DISCOUNT_AMOUNT = src.LINE_DISCOUNT_AMOUNT
					, tgt.ORDER_DISCOUNT_AMOUNT = src.ORDER_DISCOUNT_AMOUNT
					, tgt.LINE_BONUS_AMOUNT = src.LINE_BONUS_AMOUNT
					, tgt.BONUS_SHARE_AMOUNT = src.BONUS_SHARE_AMOUNT
		when not matched by source and (tgt.EXPECTED_INVOICE_DATE between @_DataCaptureStart and @_DataCaptureEnd) and tgt.OrderShippedNotInvoicedKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;
		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@RowsAffected as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;

		--!
		--! If we get here, every step completed successfully so report final state
		--!
		set @_Message = 'Completed all staging data preparation steps'
		set @_Error = 0 ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh Invoice dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out
				, @ExceptionId    = @_ExceptionId out
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	if @_Error = 0
		begin
			set @_Step = 'OnComplete'
			set @_Severity = @SEVERITY_SUCCESS
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end
	else
		begin
			set @_Step = coalesce(@_Step, 'OnError')
			set @_Severity = @SEVERITY_SEVERE
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end

	if @DebugLevel != 0 and @_Severity = @SEVERITY_INFORMATION set @_Severity = @SEVERITY_DEBUG;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 4
	/**/	begin
	/**/		raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_Message) with nowait;
	/**/		raiserror('', 0, 1) with nowait;
	/**/	end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	if @_JournalOnOff = 'ON'
		exec log4.JournalWriter
				  @Task = @_JobName
				, @FunctionName = @_FunctionName
				, @StepInFunction = @_Step
				, @MessageText = @_Message
				, @ExtraInfo = @_ProgressLog
				, @Severity = @_Severity
				, @ExceptionId = @_ExceptionId

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [privy].[OrderBacklogRefresh]...';


GO
create procedure [privy].[OrderBacklogRefresh]
(
  @LoadStart datetime
, @DebugLevel tinyint = 0
, @RowsAffected int = null out
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		privy.OrderBacklogRefresh
DESCRIPTION:		Merges any changes from the QlikView source into the staging area ready for consumption by the
					QV-to-IDW ETL process
ORIGIN DATE:		15-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		15-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>
begin
	set nocount on;

	--! Journal Constants
	declare @SEVERITY_CRITICAL int = 1;
	declare @SEVERITY_SEVERE int = 2;
	declare @SEVERITY_MAJOR int = 4;
	declare @SEVERITY_MODERATE int = 8;
	declare @SEVERITY_MINOR int = 16;
	declare @SEVERITY_CONCURRENCY int = 32;
	declare @SEVERITY_INFORMATION int = 256;
	declare @SEVERITY_SUCCESS int = 512;
	declare @SEVERITY_DEBUG int = 1024;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_RowCount int = 0;
	declare @_ReturnValue int = 0;
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_SprocStartTime datetime = getdate()
	declare	@_StepStartTime datetime
	declare	@_StepEndTime datetime
	declare	@_Step varchar(128);
	declare	@_ProgressMessage varchar(2000)
	declare	@_ExceptionId int
	declare @_JournalOnOff varchar(3) = log4.GetJournalControl(@_FunctionName, null);
	declare @_Severity smallint = @SEVERITY_INFORMATION;
	declare @_ProgressLog nvarchar(max);
	declare @_RowsAffected int = 0;
	declare @_JobName nvarchar(128) = 'QlikView Staging Data' ;

	set @_ProgressMessage = @_FunctionName
			+ ' starting at ' + coalesce(convert(varchar(24), @_SprocStartTime, 120), '') + ' with inputs: '
			+ char(10) + '    @LoadStart   : ' + coalesce(convert(varchar(24), @LoadStart, 120), '')
			+ char(10) + '    @DebugLevel  : ' + coalesce(cast(@DebugLevel as varchar(16)), 'NULL')
			+ char(10)
	set @_ProgressLog = @_ProgressMessage;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 5
	/**/     begin
	/**/         raiserror('', 0, 1) with nowait;
	/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
	/**/     end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	--! Find out if we are already in a transaction
	declare	@_TxnIsExternal bit = case when @@trancount > 0 then 1 else 0 end;

	begin try
		--!
		--!
		--!
		set @_Step = 'Collect Load Parameters';
		set @_StepStartTime = getdate();

		declare @_ParameterSource varchar(200), @_DataCaptureStart datetime, @_DataCaptureEnd datetime;
		select
			  @_ParameterSource = ModuleName
			, @_DataCaptureStart = DataCaptureStart
			, @_DataCaptureEnd = DataCaptureEnd
		from
			privy.GetLoadParameters(@_FunctionName)

		set @_ProgressMessage = 'Load Parameter Values:'
				+ char(10) + '    Parameter Value Source  : ' + coalesce(@_ParameterSource, 'NULL')
				+ char(10) + '    Data Capture Start      : ' + coalesce(convert(varchar(24), @_DataCaptureStart, 120), '')
				+ char(10) + '    Data Capture End        : ' + coalesce(convert(varchar(24), @_DataCaptureEnd, 120), '')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to fetch load parameters'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		if @_DataCaptureStart is null
			raiserror('Load Parameter: Data Capture Start cannot be null', 16, 1);

		if @_DataCaptureStart is null
			raiserror('Load Parameter: Data Capture Start cannot be null', 16, 1);

		--!
		--!
		--!
		set @_Step = 'Collect Runtime Parameters';
		set @_StepStartTime = getdate();

		declare @_UnmappedPaymentTerm varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'PAYMENT_UNMAPPED') ;
		declare @_UnmappedProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SA_UNMAPPED_ITEM') ;
		declare @_ExcludeFromQlikViewProductCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'SALES_NOT_QLIKVIEW') ;
		declare @_ExcludeFromQlikViewCustomerCategory varchar(50) = (select TEKST from [$(Icopal_profBIS)].dbo.FLEXPARAMS where PARAMTYPE = 'DWH' and PARAMNAVN = 'CUSTOMER_NOT_EXPORTED') ;

		set @_ProgressMessage = 'Parameter Values:'
				+ char(10) + '    Unmapped Payment Term                    : ' + coalesce(@_UnmappedPaymentTerm, 'NULL')
				+ char(10) + '    Unmapped Product Category                : ' + coalesce(@_UnmappedProductCategory, 'NULL')
				+ char(10) + '    Exclude From QlikView Product Category   : ' + coalesce(@_ExcludeFromQlikViewProductCategory, 'NULL')
				+ char(10) + '    Exclude From QlikView Customer Category  : ' + coalesce(@_ExcludeFromQlikViewCustomerCategory, 'NULL')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to fetch runtime parameters'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = 'Generate Working Values';
		set @_StepStartTime = getdate();

		declare @_UnmappedPaymentTermId int ;
		if len(@_UnmappedPaymentTerm) > 0 and isnumeric(@_UnmappedPaymentTerm) = 1
			set @_UnmappedPaymentTermId = cast(@_UnmappedPaymentTerm as int)

		declare @_UnmappedProductCategoryId int ;
		if len(@_UnmappedProductCategory) > 0 and isnumeric(@_UnmappedProductCategory) = 1
			set @_UnmappedProductCategoryId = cast(@_UnmappedProductCategory as int)

		declare @_ExcludeFromQlikViewProductCategoryId int ;
		if len(@_ExcludeFromQlikViewProductCategory) > 0 and isnumeric(@_ExcludeFromQlikViewProductCategory) = 1
			set @_ExcludeFromQlikViewProductCategoryId = cast(@_ExcludeFromQlikViewProductCategory as int)
		else
			set @_ExcludeFromQlikViewProductCategoryId = -2 ;

		if @_ExcludeFromQlikViewProductCategoryId is null
			raiserror('Product Category Id to exclude from QlikView extract cannot be identified', 16, 1);

		declare @_ExcludeFromQlikViewCustomerCategoryId int ;
		if len(@_ExcludeFromQlikViewCustomerCategory) > 0 and isnumeric(@_ExcludeFromQlikViewCustomerCategory) = 1
			set @_ExcludeFromQlikViewCustomerCategoryId = cast(@_ExcludeFromQlikViewCustomerCategory as int)
		else
			set @_ExcludeFromQlikViewCustomerCategoryId = -2 ;

		if @_ExcludeFromQlikViewCustomerCategoryId is null
			raiserror('Customer Category Id to exclude from QlikView extract cannot be identified', 16, 1);

		set @_ProgressMessage = 'Working Values:'
				+ char(10) + '    Unmapped Payment Term Id                    : ' + coalesce(cast(@_UnmappedPaymentTermId as varchar(16)), 'NULL')
				+ char(10) + '    Unmapped Product Category Id                : ' + coalesce(cast(@_UnmappedProductCategoryId as varchar(16)), 'NULL')
				+ char(10) + '    Exclude From QlikView Product Category Id   : ' + coalesce(cast(@_ExcludeFromQlikViewProductCategoryId as varchar(16)), 'NULL')
				+ char(10) + '    Exclude From QlikView Customer Category Id  : ' + coalesce(cast(@_ExcludeFromQlikViewCustomerCategoryId as varchar(16)), 'NULL')
				+ char(10) + cast(datediff(millisecond, @_StepStartTime, getdate()) as varchar(16)) + ' milliseconds to generate working values'
				+ char(10)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 5
		/**/     begin
		/**/         raiserror('', 0, 1) with nowait;
		/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/**/     end
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--! If there no outer transaction, use an explicit transaction so we can roll this piece back if required 
		if @_TxnIsExternal = 0 begin tran;

		set @_Step = 'Upsert Main'
		set @_StepStartTime = getdate();

		;with sourceCte
		as
		(
			--! The following columns are defined as NOT NULL on the underlying table: REC_ID, SYSTEM_ID, SITE_SOLD
			--! We use the following columns to uniquely identify each row: SYSTEM_ID, ORDER_NUMBER, ORDER_LINE_NUMBER and Uniqueifier
			select
				  ord.REC_ID
				, ord.SYSTEM_ID
				, coalesce(ord.ORDER_NUMBER, '') as [ORDER_NUMBER]
				, coalesce(ord.ORDER_LINE_NUMBER, '') as [ORDER_LINE_NUMBER]
				, row_number() over (partition by ord.SYSTEM_ID, ord.ORDER_NUMBER, ord.ORDER_LINE_NUMBER order by ord.EXPECTED_INVOICE_DATE desc, ord.REC_ID) as [Uniqueifier]
				, ord.EXPECTED_INVOICE_DATE
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.ORDER_TYPE, '') as [ORDER_TYPE]
				, case coalesce(ord.ORDER_TYPE, '')
					when '1' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
					when '2' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
					when '' then 'Not Specified At Source'
					else 'Lookup Not Found (' + coalesce(ord.ORDER_TYPE, '') + ')'
				  end as [OrderTypeName]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.SITE_SOLD as [LOCAL_SITE_SOLD]
				, ssite.SITE_ID -- Don't need to collect SBU from this as per V_SA_ORDERSNI as we will expose SiteKey in the view later
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.ITEM_NO, '') as [ITEM_NO]
				, coalesce(pCat.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as [ITEM_CATEGORY_ID]
				, EnvPcat.ENV_CATEGORY_ID
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.SOLD_TO, '') as [SOLD_TO_CUSTOMER_NO]
				, coalesce(ord.SHIP_TO, '') as [SHIP_TO_CUSTOMER_NO]
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.SALESPERSON_ID, '') as [SALESPERSON_ID]
				, coalesce(ord.SALESPERSON_NAME, '') as [SALESPERSON_NAME]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.ORDER_QUANTITY
				, coalesce(ord.ORDER_UOM, '') as [ORDER_UOM]
				, ord.STATISTIC_QUANTITY
				, coalesce(ord.STATISTIC_UOM, '') as [STATISTIC_UOM]
				, ord.QUANTITY
				-----------------------------------------------------------------------------------------------------------------------
				, coalesce(ord.UOM, '') as [LOCAL_UOM]
				, coalesce(lUom.HARMONIZED_UOM, '') as [LOCAL_UOM_HARMONIZED]
				, lUom.FACTOR as [LOCAL_UOM_FACTOR]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.ORDER_AMOUNT
				, ord.LOCAL_AMOUNT
				, ord.GROUP_AMOUNT
				, coalesce(ord.ORDER_CURRENCY, '') as [ORDER_CURRENCY]
				, coalesce(ord.LOCAL_CURRENCY, '') as [LOCAL_CURRENCY]
				-----------------------------------------------------------------------------------------------------------------------
				, ord.LINE_DISCOUNT_AMOUNT
				, ord.ORDER_DISCOUNT_AMOUNT
				, ord.LINE_BONUS_AMOUNT
				, ord.BONUS_SHARE_AMOUNT
				-----------------------------------------------------------------------------------------------------------------------
				--! Encapsulate ALL non-key columns into a hash value to speed up CDC checks during susbseqent loads
				, convert(nvarchar(32), hashbytes('MD5'
					, coalesce(convert(varchar(24), ord.EXPECTED_INVOICE_DATE, 120), 'EXPECTED_INVOICE_DATE')
						+ coalesce(ord.ORDER_TYPE, 'ORDER_TYPE')
						+ case coalesce(ord.ORDER_TYPE, '')
							when '1' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
							when '2' then 'TODO: Define Order Type (' + coalesce(ord.ORDER_TYPE, '') + ')'
							when '' then 'Not Specified At Source'
							else 'Lookup Not Found (' + coalesce(ord.ORDER_TYPE, '') + ')'
						  end
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.SITE_SOLD, 'SITE_SOLD')
						+ coalesce(cast(ssite.SITE_ID as nvarchar(30)), 'SITE_ID') -- Don't need to collect SBU from this as per V_SA_INVOICE as we will expose SiteKey in the view later
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.ITEM_NO, 'ITEM_NO')
						+ coalesce(cast(coalesce(pCat.ITEM_CATEGORY_ID, @_UnmappedProductCategoryId) as varchar(30)), 'ITEM_CATEGORY_ID')
						+ coalesce(cast(EnvPcat.ENV_CATEGORY_ID as nvarchar(30)), 'ENV_CATEGORY_ID')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.SOLD_TO, 'SOLD_TO')
						+ coalesce(ord.SHIP_TO, 'SHIP_TO')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.SALESPERSON_ID, 'SALESPERSON_ID')
						+ coalesce(ord.SALESPERSON_NAME, 'SALESPERSON_NAME')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(ord.ORDER_QUANTITY as nvarchar(30)), 'ORDER_QUANTITY')
						+ coalesce(ord.ORDER_UOM, 'ORDER_UOM') 
						+ coalesce(cast(ord.STATISTIC_QUANTITY as nvarchar(30)), 'STATISTIC_QUANTITY')
						+ coalesce( ord.STATISTIC_UOM, 'STATISTIC_UOM')
						+ coalesce(cast(ord.QUANTITY as nvarchar(30)), 'QUANTITY')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(ord.UOM, 'UOM')
						+ coalesce(lUom.HARMONIZED_UOM, 'HARMONIZED_UOM')
						+ coalesce(cast(lUom.FACTOR as nvarchar(30)), 'FACTOR')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(ord.ORDER_AMOUNT as nvarchar(30)), 'ORDER_AMOUNT')
						+ coalesce(cast(ord.LOCAL_AMOUNT as nvarchar(30)), 'LOCAL_AMOUNT')
						+ coalesce(cast(ord.GROUP_AMOUNT as nvarchar(30)), 'GROUP_AMOUNT')
						+ coalesce(ord.ORDER_CURRENCY, 'ORDER_CURRENCY')
						+ coalesce(ord.LOCAL_CURRENCY, 'LOCAL_CURRENCY')
						-----------------------------------------------------------------------------------------------------------------------
						+ coalesce(cast(ord.LINE_DISCOUNT_AMOUNT as nvarchar(30)), 'LINE_DISCOUNT_AMOUNT')
						+ coalesce(cast(ord.ORDER_DISCOUNT_AMOUNT as nvarchar(30)), 'ORDER_DISCOUNT_AMOUNT')
						+ coalesce(cast(ord.LINE_BONUS_AMOUNT as nvarchar(30)), 'LINE_BONUS_AMOUNT')
						+ coalesce(cast(ord.BONUS_SHARE_AMOUNT as nvarchar(30)), 'BONUS_SHARE_AMOUNT')), 2) as [EtlDeltaHash]
				---------------------------------------------------------------------------------------------------
			from
				[$(Icopal_profBIS)].dbo.SA_ORDER_BACKLOG as ord
			inner join [$(Icopal_profBIS)].dbo.PU_LINK_SITE as ssite
				on ssite.SYSTEM_ID = ord.SYSTEM_ID
				and ssite.LOCAL_SITE = ord.SITE_SOLD
			inner join [$(Icopal_profBIS)].dbo.MD_SITE as msite
				on msite.SITE_ID = ssite.SITE_ID
			--! Make sure we can filter for just invoices belonging to SBUs where SABIS is true
			inner join [$(Icopal_profBIS)].dbo.MD_SBU as sbu
				on sbu.SBU   = msite.SBU
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_ITEM as pCat
				on pCat.SYSTEM_ID = ord.SYSTEM_ID
				and pCat.ITEM_NO = ord.ITEM_NO
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_ENV as EnvPcat
				on EnvPcat.SYSTEM_ID = ord.SYSTEM_ID
				and EnvPcat.ITEM_NO = ord.ITEM_NO
			left outer join [$(Icopal_profBIS)].dbo.PU_LINK_UOM as lUom
				on lUom.SYSTEM_ID = ord.SYSTEM_ID
				and lUom.LOCAL_UOM = ord.UOM
			left outer join [$(Icopal_profBIS)].dbo.SA_LINK_CUSTOMER as lcc 
				on lcc.SYSTEM_ID = ord.SYSTEM_ID
				and lcc.CUSTOMER_NO = ord.SHIP_TO
			where
					ord.EXPECTED_INVOICE_DATE between @_DataCaptureStart and @_DataCaptureEnd
				--! Replicate all the filters used in Icopal_profBIS.dbo.V_SA_INVOICE (except date)
				and sbu.SABIS = 'Y'
				and ord.ORDER_TYPE in ('1', '2')
				and isnull(pCat.ITEM_CATEGORY_ID, -1) <> @_ExcludeFromQlikViewProductCategoryId
				and isnull(lcc.CUSTOMER_CATEGORY_ID, -1) <> @_ExcludeFromQlikViewCustomerCategoryId
		)
		merge into stg.OrderBacklog as tgt
		using sourceCte as src
			on src.SYSTEM_ID = tgt.SYSTEM_ID
			and src.ORDER_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.ORDER_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.ORDER_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS = tgt.ORDER_LINE_NUMBER collate SQL_Latin1_General_CP1_CI_AS
			and src.Uniqueifier = tgt.Uniqueifier
		when not matched by target
			then insert
			(  
			  EtlDeltaHash
			, EtlCreatedOn
			, EtlCreatedBy
			, EtlUpdatedOn
			, EtlUpdatedBy
			, EtlDeletedOn
			, EtlDeletedBy
			, IsDeleted
			, REC_ID
			, SYSTEM_ID
			, ORDER_NUMBER
			, ORDER_LINE_NUMBER
			, Uniqueifier
			, EXPECTED_INVOICE_DATE
			, ORDER_TYPE
			, OrderTypeName
			, LOCAL_SITE_SOLD
			, SITE_ID
			, ITEM_NO
			, ITEM_CATEGORY_ID
			, ENV_CATEGORY_ID
			, SOLD_TO_CUSTOMER_NO
			, SHIP_TO_CUSTOMER_NO
			, SALESPERSON_ID
			, SALESPERSON_NAME
			, ORDER_QUANTITY
			, ORDER_UOM
			, STATISTIC_QUANTITY
			, STATISTIC_UOM
			, QUANTITY
			, LOCAL_UOM
			, LOCAL_UOM_HARMONIZED
			, LOCAL_UOM_FACTOR
			, ORDER_AMOUNT
			, LOCAL_AMOUNT
			, GROUP_AMOUNT
			, ORDER_CURRENCY
			, LOCAL_CURRENCY
			, LINE_DISCOUNT_AMOUNT
			, ORDER_DISCOUNT_AMOUNT
			, LINE_BONUS_AMOUNT
			, BONUS_SHARE_AMOUNT
			)
			values
			(  
			  src.EtlDeltaHash
			, @LoadStart
			, @_FunctionName
			, @LoadStart
			, @_FunctionName
			, null -- EtlDeletedOn
			, null -- EtlDeletedBy
			, 'N' -- IsDeleted
			, src.REC_ID
			, src.SYSTEM_ID
			, src.ORDER_NUMBER
			, src.ORDER_LINE_NUMBER
			, src.Uniqueifier
			, src.EXPECTED_INVOICE_DATE
			, src.ORDER_TYPE
			, src.OrderTypeName
			, src.LOCAL_SITE_SOLD
			, src.SITE_ID
			, src.ITEM_NO
			, src.ITEM_CATEGORY_ID
			, src.ENV_CATEGORY_ID
			, src.SOLD_TO_CUSTOMER_NO
			, src.SHIP_TO_CUSTOMER_NO
			, src.SALESPERSON_ID
			, src.SALESPERSON_NAME
			, src.ORDER_QUANTITY
			, src.ORDER_UOM
			, src.STATISTIC_QUANTITY
			, src.STATISTIC_UOM
			, src.QUANTITY
			, src.LOCAL_UOM
			, src.LOCAL_UOM_HARMONIZED
			, src.LOCAL_UOM_FACTOR
			, src.ORDER_AMOUNT
			, src.LOCAL_AMOUNT
			, src.GROUP_AMOUNT
			, src.ORDER_CURRENCY
			, src.LOCAL_CURRENCY
			, src.LINE_DISCOUNT_AMOUNT
			, src.ORDER_DISCOUNT_AMOUNT
			, src.LINE_BONUS_AMOUNT
			, src.BONUS_SHARE_AMOUNT
			)
		when matched and tgt.EtlDeltaHash <> src.EtlDeltaHash or tgt.IsDeleted = 'Y'
			then update set
					  tgt.EtlDeltaHash = src.EtlDeltaHash
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
					, tgt.IsDeleted = 'N'
					, tgt.REC_ID = src.REC_ID
					, tgt.EXPECTED_INVOICE_DATE = src.EXPECTED_INVOICE_DATE
					, tgt.ORDER_TYPE = src.ORDER_TYPE
					, tgt.OrderTypeName = src.OrderTypeName
					, tgt.LOCAL_SITE_SOLD = src.LOCAL_SITE_SOLD
					, tgt.SITE_ID = src.SITE_ID
					, tgt.ITEM_NO = src.ITEM_NO
					, tgt.ITEM_CATEGORY_ID = src.ITEM_CATEGORY_ID
					, tgt.ENV_CATEGORY_ID = src.ENV_CATEGORY_ID
					, tgt.SOLD_TO_CUSTOMER_NO = src.SOLD_TO_CUSTOMER_NO
					, tgt.SHIP_TO_CUSTOMER_NO = src.SHIP_TO_CUSTOMER_NO
					, tgt.SALESPERSON_ID = src.SALESPERSON_ID
					, tgt.SALESPERSON_NAME = src.SALESPERSON_NAME
					, tgt.ORDER_QUANTITY = src.ORDER_QUANTITY
					, tgt.ORDER_UOM = src.ORDER_UOM
					, tgt.STATISTIC_QUANTITY = src.STATISTIC_QUANTITY
					, tgt.STATISTIC_UOM = src.STATISTIC_UOM
					, tgt.QUANTITY = src.QUANTITY
					, tgt.LOCAL_UOM = src.LOCAL_UOM
					, tgt.LOCAL_UOM_HARMONIZED = src.LOCAL_UOM_HARMONIZED
					, tgt.LOCAL_UOM_FACTOR = src.LOCAL_UOM_FACTOR
					, tgt.ORDER_AMOUNT = src.ORDER_AMOUNT
					, tgt.LOCAL_AMOUNT = src.LOCAL_AMOUNT
					, tgt.GROUP_AMOUNT = src.GROUP_AMOUNT
					, tgt.ORDER_CURRENCY = src.ORDER_CURRENCY
					, tgt.LOCAL_CURRENCY = src.LOCAL_CURRENCY
					, tgt.LINE_DISCOUNT_AMOUNT = src.LINE_DISCOUNT_AMOUNT
					, tgt.ORDER_DISCOUNT_AMOUNT = src.ORDER_DISCOUNT_AMOUNT
					, tgt.LINE_BONUS_AMOUNT = src.LINE_BONUS_AMOUNT
					, tgt.BONUS_SHARE_AMOUNT = src.BONUS_SHARE_AMOUNT
		when not matched by source and (tgt.EXPECTED_INVOICE_DATE between @_DataCaptureStart and @_DataCaptureEnd) and tgt.OrderBacklogKey >= 100
			then update set
					  tgt.IsDeleted = 'Y'
					, tgt.EtlDeletedOn = @LoadStart
					, tgt.EtlDeletedBy = @_FunctionName
					, tgt.EtlUpdatedOn = @LoadStart
					, tgt.EtlUpdatedBy = @_FunctionName
		;

		set @RowsAffected = @@rowcount;
		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@RowsAffected as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--! Only commit transactions started within this procedure
		--!
		if @_TxnIsExternal = 0 and (xact_state() = 1 or @@trancount > 0) commit tran ;

		--!
		--! If we get here, every step completed successfully so report final state
		--!
		set @_Message = 'Completed all staging data preparation steps'
		set @_Error = 0 ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to refresh Invoice dimension at step '
			+ coalesce('[' + @_Step + ']', 'NULL');

		--! If we have an uncommittable external transaction (see BOL), or a deadlock
		--! we can't do anything else until we roll that back. Alternatively, if we
		--! started the transaction we should roll it back otherwise or let the caller
		--! handle its own external txn 
		if (xact_state() = -1) or (xact_state() = 1 and error_number() = 1205) or (xact_state() = 1 and @_TxnIsExternal = 0)
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end
		
		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out
				, @ExceptionId    = @_ExceptionId out
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndProc:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	if @_Error = 0
		begin
			set @_Step = 'OnComplete'
			set @_Severity = @SEVERITY_SUCCESS
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end
	else
		begin
			set @_Step = coalesce(@_Step, 'OnError')
			set @_Severity = @SEVERITY_SEVERE
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end

	if @DebugLevel != 0 and @_Severity = @SEVERITY_INFORMATION set @_Severity = @SEVERITY_DEBUG;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 4
	/**/	begin
	/**/		raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_Message) with nowait;
	/**/		raiserror('', 0, 1) with nowait;
	/**/	end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	if @_JournalOnOff = 'ON'
		exec log4.JournalWriter
				  @Task = @_JobName
				, @FunctionName = @_FunctionName
				, @StepInFunction = @_Step
				, @MessageText = @_Message
				, @ExtraInfo = @_ProgressLog
				, @Severity = @_Severity
				, @ExceptionId = @_ExceptionId

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [etl].[SetStagingDelta]...';


GO
create procedure [etl].[SetStagingDelta]
(
  @LoadEnd datetime = null
, @DebugLevel tinyint = 0
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		etl.SetStagingDelta
DESCRIPTION:		Executes a series of private worker procedures to caputure current state (delta hash values) to
					facillitate subsequent delta loads
					into interim data warehouse
ORIGIN DATE:		12-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		12-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Journal Constants
	declare @SEVERITY_CRITICAL int = 1;
	declare @SEVERITY_SEVERE int = 2;
	declare @SEVERITY_MAJOR int = 4;
	declare @SEVERITY_MODERATE int = 8;
	declare @SEVERITY_MINOR int = 16;
	declare @SEVERITY_CONCURRENCY int = 32;
	declare @SEVERITY_INFORMATION int = 256;
	declare @SEVERITY_SUCCESS int = 512;
	declare @SEVERITY_DEBUG int = 1024;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_RowCount int = 0;
	declare @_ReturnValue int = 0;
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_SprocStartTime datetime = getdate()
	declare	@_StepStartTime datetime
	declare	@_StepEndTime datetime
	declare	@_Step varchar(128);
	declare	@_ProgressMessage varchar(2000)
	declare	@_ExceptionId int
	declare @_JournalOnOff varchar(3) = log4.GetJournalControl(@_FunctionName, null);
	declare @_Severity smallint = @SEVERITY_INFORMATION;
	declare @_ProgressLog nvarchar(max);
	declare @_RowsAffected int = 0;
	declare @_JobName nvarchar(128) = 'QlikView Staging Data' ;

	set @_ProgressMessage = @_FunctionName
			+ ' starting at ' + coalesce(convert(varchar(24), @_SprocStartTime, 120), '') + ' with inputs: '
			+ char(10) + '    @LoadEnd   : ' + coalesce(convert(varchar(24), @LoadEnd, 120), '')
			+ char(10) + '    @DebugLevel      : ' + coalesce(cast(@DebugLevel as varchar(16)), 'NULL')
			+ char(10)
	set @_ProgressLog = @_ProgressMessage;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 5
	/**/     begin
	/**/         raiserror('', 0, 1) with nowait;
	/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
	/**/     end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


	begin try
		--! If Load Start time hasn't been passed in then set it now
		set @LoadEnd = coalesce(@LoadEnd, getdate())

		--!
		--!
		--!
		set @_Step = 'Record Product Category Deltas';
		set @_StepStartTime = getdate();

		exec privy.ProductCategoryControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record Product Deltas';
		set @_StepStartTime = getdate();

		exec privy.ProductControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record Customer Deltas';
		set @_StepStartTime = getdate();

		exec privy.CustomerControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record Business Unit Deltas';
		set @_StepStartTime = getdate();

		exec privy.BusinessUnitControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record Site Deltas';
		set @_StepStartTime = getdate();

		exec privy.SiteControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record Payment Term Deltas';
		set @_StepStartTime = getdate();

		exec privy.PaymentTermControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record Invoice Deltas';
		set @_StepStartTime = getdate();

		exec privy.InvoiceControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record OrderShippedNotInvoiced Deltas';
		set @_StepStartTime = getdate();

		exec privy.OrderShippedNotInvoicedControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = 'Record OrderBacklog Deltas';
		set @_StepStartTime = getdate();

		exec privy.OrderBacklogControlReset @LoadEnd = @LoadEnd, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/





		--!
		--! By this point there should be no uncommitted transactions
		--!
		if xact_state() = -1 or xact_state() = 1 or @@trancount > 0
			raiserror('Completed running all steps but found %i uncommitted transactions (expected zero)', 16, 1, @@trancount);

		--!
		--! If we get here, every step completed successfully so report final state
		--!
		set @_Message = 'Completed all staging data preparation steps'
--		set @_Message = 'WARNING! All steps temporarily disabled to support ICS load testing'
		set @_Error = 0 ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to prepare staging data at step: ' + coalesce('[' + @_Step + ']', 'NULL')

		--! Clean up any leftover transactions
		if xact_state() = -1 or xact_state() = 1
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end

		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out
				, @ExceptionId    = @_ExceptionId out
		;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndEx:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	if @_Error = 0
		begin
			set @_Step = 'OnComplete'
			set @_Severity = @SEVERITY_SUCCESS
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end
	else
		begin
			set @_Step = coalesce(@_Step, 'OnError')
			set @_Severity = @SEVERITY_SEVERE
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end

	if @DebugLevel != 0 and @_Severity = @SEVERITY_INFORMATION set @_Severity = @SEVERITY_DEBUG;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 3
	/**/	begin
	/**/		raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_Message) with nowait;
	/**/		raiserror('', 0, 1) with nowait;
	/**/	end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	if @_JournalOnOff = 'ON'
		exec log4.JournalWriter
				  @Task = @_JobName
				, @FunctionName = @_FunctionName
				, @StepInFunction = @_Step
				, @MessageText = @_Message
				, @ExtraInfo = @_ProgressLog
				, @Severity = @_Severity
				, @ExceptionId = @_ExceptionId

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating [etl].[PrepareStagingData]...';


GO
create procedure [etl].[PrepareStagingData]
(
  @LoadStart datetime = null
, @DebugLevel tinyint = 0
)
as
--<CommentHeader>
/**********************************************************************************************************************

Properties
==========
PROCEDURE NAME:		etl.PrepareStagingData
DESCRIPTION:		Executes a series of private worker procedures to prepare all staging data prior to ETL extract
					into interim data warehouse
ORIGIN DATE:		09-JUN-2017
ORIGINAL AUTHOR:	Greg M. Lucas

Returns
=======
@@Error - always zero on success

Additional Notes
================

REVISION HISTORY
=====================================================================================================================
Version	ChangeDate		Author	BugRef	Narrative
=======	============	======	=======	=============================================================================
001		09-JUN-2017		GML		N/A		Created
------- ------------	------	-------	-----------------------------------------------------------------------------

**********************************************************************************************************************/
--</CommentHeader>

begin
	set nocount on;

	--! Journal Constants
	declare @SEVERITY_CRITICAL int = 1;
	declare @SEVERITY_SEVERE int = 2;
	declare @SEVERITY_MAJOR int = 4;
	declare @SEVERITY_MODERATE int = 8;
	declare @SEVERITY_MINOR int = 16;
	declare @SEVERITY_CONCURRENCY int = 32;
	declare @SEVERITY_INFORMATION int = 256;
	declare @SEVERITY_SUCCESS int = 512;
	declare @SEVERITY_DEBUG int = 1024;

	--! Standard/ExceptionHandler variables
	declare	@_FunctionName nvarchar(255) = quotename(object_schema_name(@@procid)) + '.' + quotename(object_name(@@procid));
	declare	@_Error int = 0;
	declare @_RowCount int = 0;
	declare @_ReturnValue int = 0;
	declare	@_Message nvarchar(512);
	declare	@_ErrorContext nvarchar(512);
	declare	@_SprocStartTime datetime = getdate()
	declare	@_StepStartTime datetime
	declare	@_StepEndTime datetime
	declare	@_Step varchar(128);
	declare	@_ProgressMessage varchar(2000)
	declare	@_ExceptionId int
	declare @_JournalOnOff varchar(3) = log4.GetJournalControl(@_FunctionName, null);
	declare @_Severity smallint = @SEVERITY_INFORMATION;
	declare @_ProgressLog nvarchar(max);
	declare @_RowsAffected int = 0;
	declare @_JobName nvarchar(128) = 'QlikView Staging Data' ;

	set @_ProgressMessage = @_FunctionName
			+ ' starting at ' + coalesce(convert(varchar(24), @_SprocStartTime, 120), '') + ' with inputs: '
			+ char(10) + '    @LoadStart       : ' + coalesce(convert(varchar(24), @LoadStart, 120), '')
			+ char(10) + '    @DebugLevel      : ' + coalesce(cast(@DebugLevel as varchar(16)), 'NULL')
			+ char(10)
	set @_ProgressLog = @_ProgressMessage;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 4
	/**/     begin
	/**/         raiserror('', 0, 1) with nowait;
	/**/         raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
	/**/     end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


	begin try
		--! If Load Start time hasn't been passed in then set it now
		set @LoadStart = coalesce(@LoadStart, getdate())

		--!
		--!
		--!
		set @_Step = '1. Rebuild Product Category Hierarchy (Map)';
		set @_StepStartTime = getdate();

		exec privy.ProductCategoryHierarchyRebuild @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = '2. Rebuild Product Category Hierarchy (Flat)';
		set @_StepStartTime = getdate();

		exec privy.ProductCategoryRefresh @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = '3. Rebuild Customer Category Hierarchy';
		set @_StepStartTime = getdate();

		exec privy.CustomerCategoryHierarchyRebuild @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = '4. Refresh Product (Dimension)';
		set @_StepStartTime = getdate();

		exec privy.ProductRefresh @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = '5. Refresh Customer (Dimension)';
		set @_StepStartTime = getdate();

		exec privy.CustomerRefresh @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = '6. Refresh BusinessUnit (Dimension)';
		set @_StepStartTime = getdate();

		exec privy.BusinessUnitRefresh @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = '7. Refresh Site (Dimension)';
		set @_StepStartTime = getdate();

		exec privy.SiteRefresh @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--!
		--!
		set @_Step = '8. Refresh Payment Term (Dimension)';
		set @_StepStartTime = getdate();

		exec privy.PaymentTermRefresh @LoadStart = @LoadStart, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = '9. Refresh Invoice (Fact)';
		set @_StepStartTime = getdate();

		exec privy.InvoiceRefresh @LoadStart = @LoadStart, @DebugLevel = @DebugLevel, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = '10. Refresh OrderShippedNotInvoiced (Fact)';
		set @_StepStartTime = getdate();

		exec privy.OrderShippedNotInvoicedRefresh @LoadStart = @LoadStart, @DebugLevel = @DebugLevel, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

		--!
		--!
		--!
		set @_Step = '11. Refresh OrderBacklog (Fact)';
		set @_StepStartTime = getdate();

		exec privy.OrderBacklogRefresh @LoadStart = @LoadStart, @DebugLevel = @DebugLevel, @RowsAffected = @_RowCount out ;

		set @_ProgressMessage = 'Step: "' +  @_Step + '" processed ' + coalesce(cast(@_RowCount as varchar(16)), 'NULL') + ' row(s)'
				+ ' in ' + log4.FormatElapsedTime(@_StepStartTime, null, 3)
		set @_ProgressLog += coalesce(char(10) + @_ProgressMessage, '');

		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
		/**/ if @DebugLevel > 4 raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_ProgressMessage) with nowait;
		/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/


		--!
		--! By this point there should be no uncommitted transactions
		--!
		if xact_state() = -1 or xact_state() = 1 or @@trancount > 0
			raiserror('Completed running all steps but found %i uncommitted transactions (expected zero)', 16, 1, @@trancount);

		--!
		--! If we get here, every step completed successfully so report final state
		--!
		set @_Message = 'Completed all staging data preparation steps'
--		set @_Message = 'Completed all active staging data preparation steps (some steps were disabled)'
--		set @_Message = 'WARNING! All steps temporarily disabled to support ICS load testing'
		set @_Error = 0 ;
	end try
	begin catch
		set @_ErrorContext = 'Failed to prepare staging data at step: ' + coalesce('[' + @_Step + ']', 'NULL')

		--! Clean up any leftover transactions
		if xact_state() = -1 or xact_state() = 1
			begin
				rollback tran;
				set @_ErrorContext = @_ErrorContext + ' (Forced roll back all changes)';
			end

		exec log4.ExceptionHandler
				  @ErrorContext   = @_ErrorContext
				, @ErrorProcedure = @_FunctionName
				, @ErrorNumber    = @_Error out
				, @ReturnMessage  = @_Message out
				, @ExceptionId    = @_ExceptionId out
		;
	end catch

--/////////////////////////////////////////////////////////////////////////////////////////////////
EndEx:
--/////////////////////////////////////////////////////////////////////////////////////////////////

	if @_Error = 0
		begin
			set @_Step = 'OnComplete'
			set @_Severity = @SEVERITY_SUCCESS
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' in a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end
	else
		begin
			set @_Step = coalesce(@_Step, 'OnError')
			set @_Severity = @SEVERITY_SEVERE
			set @_Message = case when len(@_Message) > 450 then substring(@_Message, 1, 450) + '...' else coalesce(@_Message, @_Step) end
							+ ' after a total run time of ' + log4.FormatElapsedTime(@_SprocStartTime, null, 3)
			set @_ProgressLog = @_ProgressLog + char(10) + @_Message
		end

	if @DebugLevel != 0 and @_Severity = @SEVERITY_INFORMATION set @_Severity = @SEVERITY_DEBUG;

	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
	/**/ if @DebugLevel > 3
	/**/	begin
	/**/		raiserror('DEBUG - %s: %s', 0, 1, @_FunctionName, @_Message) with nowait;
	/**/		raiserror('', 0, 1) with nowait;
	/**/	end
	/*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/

	if @_JournalOnOff = 'ON'
		exec log4.JournalWriter
				  @Task = @_JobName
				, @FunctionName = @_FunctionName
				, @StepInFunction = @_Step
				, @MessageText = @_Message
				, @ExtraInfo = @_ProgressLog
				, @Severity = @_Severity
				, @ExceptionId = @_ExceptionId

	--! Finally, throw an exception that will be detected by the caller
	if @_Error > 0 raiserror(@_Message, 16, 99);

	set nocount off;

	--! Return the value of @@ERROR (which will be zero on success)
	return (@_Error);
end
GO
PRINT N'Creating Permission...';


GO
GRANT SELECT
    ON SCHEMA::[etl] TO [EtlReaders];


GO
PRINT N'Creating Permission...';


GO
GRANT SELECT
    ON SCHEMA::[etl] TO [EtlDevelopers];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON SCHEMA::[etl] TO [EtlReaders];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON SCHEMA::[etl] TO [EtlDevelopers];


GO
PRINT N'Creating Permission...';


GO
GRANT SELECT
    ON SCHEMA::[log4] TO [EtlDevelopers];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON SCHEMA::[log4] TO PUBLIC;


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON SCHEMA::[log4] TO [EtlDevelopers];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4].[FormatElapsedTime] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4].[JournalWriter] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4].[ExceptionHandler] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4].[GetJournalControl] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4Private].[SessionInfoOutput] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON SCHEMA::[log4Utils] TO PUBLIC;


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4Utils].[PrintString] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4Utils].[JournalReader] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4Utils].[JournalPrinter] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT EXECUTE
    ON OBJECT::[log4Utils].[ExceptionReader] TO PUBLIC
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT UPDATE
    ON OBJECT::[privy].[StagingLoadParameter] TO [EtlDevelopers]
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT SELECT
    ON OBJECT::[privy].[StagingLoadParameter] TO [EtlDevelopers]
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT SELECT
    ON SCHEMA::[stg] TO [EtlDevelopers];


GO
PRINT N'Creating Permission...';


GO
GRANT ALTER
    ON OBJECT::[stg].[CustomerCategoryHierarchy] TO [EtlReaders]
    AS [dbo];


GO
PRINT N'Creating Permission...';


GO
GRANT ALTER
    ON OBJECT::[stg].[ProductCategoryHierarchy] TO [EtlReaders]
    AS [dbo];


GO
PRINT N'Creating [etl].[InvoiceDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Invoice changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'InvoiceDelta';


GO
PRINT N'Creating [etl].[CustomerDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Customer changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'CustomerDelta';


GO
PRINT N'Creating [etl].[BusinessUnitDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Business Unit changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'BusinessUnitDelta';


GO
PRINT N'Creating [etl].[SetStagingDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Executes a series of private worker procedures to caputure current state (delta hash values) to facillitate subsequent delta loads', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'PROCEDURE', @level1name = N'SetStagingDelta';


GO
PRINT N'Creating [etl].[PrepareStagingData].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Executes a series of private worker procedures to prepare all staging data prior to ETL extract into interim data warehouse', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'PROCEDURE', @level1name = N'PrepareStagingData';


GO
PRINT N'Creating [etl].[SiteDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Site changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'SiteDelta';


GO
PRINT N'Creating [etl].[ProductDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Product changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'ProductDelta';


GO
PRINT N'Creating [etl].[ProductCategoryDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Product Category changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'ProductCategoryDelta';


GO
PRINT N'Creating [etl].[PaymentTermDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes Payment Term changes (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'PaymentTermDelta';


GO
PRINT N'Creating [etl].[OrderShippedNotInvoicedDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes changes to Orders shipped-not-invoiced (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'OrderShippedNotInvoicedDelta';


GO
PRINT N'Creating [etl].[OrderBacklogDelta].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Exposes changes to Orders shipped-not-invoiced (new, changed and deleted) in the format best suited to populate the Interim Data Warehouse/Mart', @level0type = N'SCHEMA', @level0name = N'etl', @level1type = N'VIEW', @level1name = N'OrderBacklogDelta';


GO
PRINT N'Creating [log4].[FormatElapsedTime].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns a string describing the time elapsed between start and end time', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'FUNCTION', @level1name = N'FormatElapsedTime';


GO
PRINT N'Creating [log4].[JournalWriter].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Adds a journal entry summarising task progress, completion or failure msgs etc.', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'JournalWriter';


GO
PRINT N'Creating [log4].[ExceptionHandler].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns error info as output parameters and writes info to Exception table', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'PROCEDURE', @level1name = N'ExceptionHandler';


GO
PRINT N'Creating [log4].[GetJournalControl].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns the ON/OFF value for the specified Journal Name, or Group Name if Module not found or the system default if neither is found', @level0type = N'SCHEMA', @level0name = N'log4', @level1type = N'FUNCTION', @level1name = N'GetJournalControl';


GO
PRINT N'Creating [log4Private].[SessionInfoOutput].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Outputs session info from master.sys.dm_exec_sessions for the current @@SPID', @level0type = N'SCHEMA', @level0name = N'log4Private', @level1type = N'PROCEDURE', @level1name = N'SessionInfoOutput';


GO
PRINT N'Creating [log4Utils].[JournalCleanup].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Deletes all Journal and Exception entries older than the specified days', @level0type = N'SCHEMA', @level0name = N'log4Utils', @level1type = N'PROCEDURE', @level1name = N'JournalCleanup';


GO
PRINT N'Creating [log4Utils].[PrintString].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Prints the supplied string respecting all line feeds and/or carriage returns except where no line feeds are found, in which case the output is printed in user-specified lengths', @level0type = N'SCHEMA', @level0name = N'log4Utils', @level1type = N'PROCEDURE', @level1name = N'PrintString';


GO
PRINT N'Creating [log4Utils].[JournalReader].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns all Journal entries matching the specified search criteria', @level0type = N'SCHEMA', @level0name = N'log4Utils', @level1type = N'PROCEDURE', @level1name = N'JournalReader';


GO
PRINT N'Creating [log4Utils].[JournalPrinter].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Prints the contents of JournalDetail for the specified Journal ID respecting all line feeds and/or carriage returns', @level0type = N'SCHEMA', @level0name = N'log4Utils', @level1type = N'PROCEDURE', @level1name = N'JournalPrinter';


GO
PRINT N'Creating [log4Utils].[ExceptionReader].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns all Exceptions matching the specified search criteria', @level0type = N'SCHEMA', @level0name = N'log4Utils', @level1type = N'PROCEDURE', @level1name = N'ExceptionReader';


GO
PRINT N'Creating [privy].[GetLoadParameters].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = N'Returns the load parameters for the specified module or override if set, otherwise the default parameters if the module is not recognised', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'FUNCTION', @level1name = N'GetLoadParameters';


GO
PRINT N'Creating [privy].[InvoiceRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'InvoiceRefresh';


GO
PRINT N'Creating [privy].[InvoiceControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Invoice records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'InvoiceControlReset';


GO
PRINT N'Creating [privy].[CustomerRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'CustomerRefresh';


GO
PRINT N'Creating [privy].[CustomerControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Customer records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'CustomerControlReset';


GO
PRINT N'Creating [privy].[CustomerCategoryHierarchyRebuild].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Truncates and reloads the privy.CustomerCategoryHierarchy table (which is subsequently used to generate a flattened and somwhat conformed customer category hierarchy in the Customer extract view', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'CustomerCategoryHierarchyRebuild';


GO
PRINT N'Creating [privy].[BusinessUnitRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'BusinessUnitRefresh';


GO
PRINT N'Creating [privy].[BusinessUnitControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Business Unit records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'BusinessUnitControlReset';


GO
PRINT N'Creating [privy].[ProductCategoryHierarchyRebuild].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Truncates and reloads the privy.ProductCategoryHierarchy table (which is subsequently used to generate a flattened and somwhat conformed product category hierarchy in the prpoduct extract view', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'ProductCategoryHierarchyRebuild';


GO
PRINT N'Creating [privy].[ProductCategoryControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Product Category records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'ProductCategoryControlReset';


GO
PRINT N'Creating [privy].[PaymentTermRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'PaymentTermRefresh';


GO
PRINT N'Creating [privy].[PaymentTermControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted PaymentTerm records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'PaymentTermControlReset';


GO
PRINT N'Creating [privy].[OrderShippedNotInvoicedRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'OrderShippedNotInvoicedRefresh';


GO
PRINT N'Creating [privy].[OrderShippedNotInvoicedControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Order (SNI) records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'OrderShippedNotInvoicedControlReset';


GO
PRINT N'Creating [privy].[OrderBacklogRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'OrderBacklogRefresh';


GO
PRINT N'Creating [privy].[OrderBacklogControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Order (SNI) records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'OrderBacklogControlReset';


GO
PRINT N'Creating [privy].[SiteRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'SiteRefresh';


GO
PRINT N'Creating [privy].[SiteControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Site records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'SiteControlReset';


GO
PRINT N'Creating [privy].[ProductRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'ProductRefresh';


GO
PRINT N'Creating [privy].[ProductControlReset].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Records new, changed and deleted Product records (used to identify deltas on the next load)', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'ProductControlReset';


GO
PRINT N'Creating [privy].[ProductCategoryRefresh].[MS_Description]...';


GO
EXECUTE sp_addextendedproperty @name = N'MS_Description', @value = 'Merges any changes from the QlikView source into the staging area ready for consumption by the QV-to-IDW ETL process', @level0type = N'SCHEMA', @level0name = N'privy', @level1type = N'PROCEDURE', @level1name = N'ProductCategoryRefresh';


GO
/*
Post-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be appended to the build script.		
 Use SQLCMD syntax to include a file in the post-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the post-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
set nocount on
GO

merge into [log4Private].[JournalControl] as Target
using (values
  ('SYSTEM_DEFAULT','ON')
 ,('SYSTEM_OVERRIDE','ON')
) as Source ([ModuleName],[OnOffSwitch])
on (Target.[ModuleName] = Source.[ModuleName])
when matched and (
	nullif(Source.[OnOffSwitch], Target.[OnOffSwitch]) is not null or nullif(Target.[OnOffSwitch], Source.[OnOffSwitch]) is not null) then
 update set
  [OnOffSwitch] = Source.[OnOffSwitch]
when not matched by target then
 insert([ModuleName],[OnOffSwitch])
 values(Source.[ModuleName],Source.[OnOffSwitch])
when not matched by source then 
 delete
;
GO
declare @mergeError int
 , @mergeCount int
select @mergeError = @@error, @mergeCount = @@rowcount
if @mergeError != 0
 begin
 print 'ERROR OCCURRED IN MERGE FOR [log4Private].[JournalControl]. Rows affected: ' + cast(@mergeCount as varchar(100)); -- SQL should always return zero rows affected
 end
else
 begin
 print '[log4Private].[JournalControl] rows affected by MERGE: ' + cast(@mergeCount as varchar(100));
 end
GO

set nocount off
GO

--!
--! privy.StagingLoadParameter.data.sql
--!
;with sourceCte (ModuleName, DataCaptureStart, DataCaptureEnd)
as
(
			  select cast('' as varchar(200))					, cast(null as datetime)	, cast(null as datetime)
	union all select 'OVERRIDE'									, null						, null
	union all select 'DEFAULT'									, '20170101 00:00:00'		, '20201231 23:59:59.997'
	union all select '[privy].[InvoiceRefresh]'					, '20170101 00:00:00'		, '20171231 23:59:59.997'
	union all select '[privy].[OrderShippedNotInvoicedRefresh]'	, '20170101 00:00:00'		, '20171231 23:59:59.997'
	union all select '[privy].[OrderBacklogRefresh]'			, '20170101 00:00:00'		, '20171231 23:59:59.997'
)
merge into privy.StagingLoadParameter as tgt
using sourceCte as src
	on src.ModuleName = tgt.ModuleName
when not matched and len(src.ModuleName) > 0
	then insert
	(
	  ModuleName
	, DataCaptureStart
	, DataCaptureEnd
	)
	values
	(
	  src.ModuleName
	, src.DataCaptureStart
	, src.DataCaptureEnd
	)
when matched and len(src.ModuleName) > 0
	then update
		set
			  tgt.DataCaptureStart = src.DataCaptureStart
			, tgt.DataCaptureEnd = src.DataCaptureEnd
when not matched by source
	then delete;
GO


set nocount on
GO

merge into [log4Private].[Severity] as Target
using (values
  (1,'Showstopper/Critical Failure')
 ,(2,'Severe Failure')
 ,(4,'Major Failure')
 ,(8,'Moderate Failure')
 ,(16,'Minor Failure')
 ,(32,'Concurrency Violation')
 ,(256,'Informational')
 ,(512,'Success')
 ,(1024,'Debug')
) as Source ([SeverityId],[SeverityName])
on (Target.[SeverityId] = Source.[SeverityId])
when matched and (
	nullif(Source.[SeverityName], Target.[SeverityName]) is not null or nullif(Target.[SeverityName], Source.[SeverityName]) is not null) then
 update set
  [SeverityName] = Source.[SeverityName]
when not matched by target then
 insert([SeverityId],[SeverityName])
 values(Source.[SeverityId],Source.[SeverityName])
when not matched by source then 
 delete
;
GO
declare @mergeError int
 , @mergeCount int
select @mergeError = @@error, @mergeCount = @@rowcount
if @mergeError != 0
 begin
 print 'ERROR OCCURRED IN MERGE FOR [log4Private].[Severity]. Rows affected: ' + cast(@mergeCount as varchar(100)); -- SQL should always return zero rows affected
 end
else
 begin
 print '[log4Private].[Severity] rows affected by MERGE: ' + cast(@mergeCount as varchar(100));
 end
GO

set nocount off
GO


set identity_insert stg.ProductCategory on;
GO

;with sourceCte (ProductCategoryKey, IsDeleted, ProductCategoryCode, ProductCategoryName, ProductCategoryDescription)
as
(
			  select -1, 'N', 'N/S', 'Not Specified at Source'		, 'Indicates that the value in the source system was NULL'
	union all select -2, 'N', 'N/F', 'Lookup Not Found'				, 'Indicates that the source system provided a value but that there is no matching lookup'
	union all select -3, 'N', 'N/I', 'Not Implemented in Source'	, 'Used when the source system does not support the concept of a Business Unit'
	union all select -4, 'N', 'N/A', 'Not Applicable'				, 'Used in a context where Business Unit has no relevance in this context'
	union all select -5, 'N', 'N/D', 'Not Defined'					, 'The logic to identify the Business Unit has not been supplied or specified'
)
merge into stg.ProductCategory as tgt
using sourceCte as src
	on src.ProductCategoryKey = tgt.ProductCategoryKey
when not matched
	then insert
	(
	  ProductCategoryKey
	, IsDeleted
	, EtlDeltaHash
	, EtlCreatedOn
	, EtlCreatedBy
	, EtlUpdatedOn
	, EtlUpdatedBy
	, EtlDeletedOn
	, EtlDeletedBy
	, NativeProductCategoryKey
	, ProductCategoryId
	, ProductCategoryName
	, NodeDepth
	, Level3Id
	, Level3Name
	, Level2Id
	, Level2Name
	, Level1Id
	, Level1Name
	, ProductCategoryDescription
	)
	values
	(
	  src.ProductCategoryKey
	, src.IsDeleted
	, src.ProductCategoryCode -- EtlDeltaHash
	, getdate() -- EtlCreatedOn
	, 'add seed values' -- EtlCreatedBy
	, getdate() -- EtlUpdatedOn
	, 'add seed values'  -- EtlUpdatedBy
	, null -- EtlDeletedOn
	, null -- EtlDeletedBy
	, src.ProductCategoryCode -- NativeProductCategoryKey
	, src.ProductCategoryKey
	, src.ProductCategoryName
	, 1
	, src.ProductCategoryKey
	, src.ProductCategoryName
	, src.ProductCategoryKey
	, src.ProductCategoryName
	, src.ProductCategoryKey
	, src.ProductCategoryName
	, src.ProductCategoryDescription
	)
when matched
	and tgt.IsDeleted <> src.IsDeleted
	or tgt.NativeProductCategoryKey <> src.ProductCategoryCode
	or tgt.ProductCategoryId <> src.ProductCategoryKey
	or tgt.ProductCategoryName <> src.ProductCategoryName
	or tgt.ProductCategoryDescription <> src.ProductCategoryDescription
then update
	set
		  tgt.IsDeleted = src.IsDeleted
		, tgt.EtlDeltaHash = src.ProductCategoryCode
		, tgt.EtlUpdatedOn = getdate()
		, tgt.EtlUpdatedBy = 'update seed values' 
		, tgt.EtlDeletedOn = case when src.IsDeleted = 'Y' then getdate() else tgt.EtlDeletedOn end
		, tgt.EtlDeletedBy = case when src.IsDeleted = 'Y' then 'update seed values' else tgt.EtlDeletedBy end
		, tgt.NativeProductCategoryKey = src.ProductCategoryCode
		, tgt.ProductCategoryId = src.ProductCategoryKey
		, tgt.ProductCategoryName = src.ProductCategoryName
		, tgt.Level3Id = src.ProductCategoryKey
		, tgt.Level3Name = src.ProductCategoryName
		, tgt.Level2Id = src.ProductCategoryKey
		, tgt.Level2Name = src.ProductCategoryName
		, tgt.Level1Id = src.ProductCategoryKey
		, tgt.Level1Name = src.ProductCategoryName
		, tgt.ProductCategoryDescription = src.ProductCategoryDescription
;
	
set identity_insert stg.ProductCategory off;
GO

set identity_insert stg.Product on;
GO

;with sourceCte (ProductKey, IsDeleted, QlikViewSourceSystemId, ProductNumber, ProductName, ProductDescription1)
as
(
			  select -1, 'N', 100000, 'N/S', 'Not Specified at Source'	, 'Indicates that the value in the source system was NULL'
	union all select -2, 'N', 100000, 'N/F', 'Lookup Not Found'			, 'Indicates that the source system provided a value but that there is no matching lookup'
	union all select -3, 'N', 100000, 'N/I', 'Not Implemented in Source'	, 'Used when the source system does not support the concept of a product'
	union all select -4, 'N', 100000, 'N/A', 'Not Applicable'			, 'Used in a context where product has no relevance in this context'
	union all select -5, 'N', 100000, 'N/D', 'Not Defined'				, 'The logic to identify the product has not been supplied or specified'
)
merge into stg.Product as tgt
using sourceCte as src
	on src.ProductKey = tgt.ProductKey
when not matched
	then insert
	(
	  ProductKey
	, IsDeleted
	, EtlDeltaHash
	, EtlCreatedOn
	, EtlCreatedBy
	, EtlUpdatedOn
	, EtlUpdatedBy
	, EtlDeletedOn
	, EtlDeletedBy
	, QlikViewSourceSystemId
	, NativeProductKey
	, ProductNumber
	, ProductName
	, ProductTypeId
	, ProductTypeName
	, ProductGnit
	, ProductDescription1
	, ProductDescription2
	, LocalProductGroup1
	, LocalProductGroup2
	, LocalProductGroup3
	, LocalProductGroup4
	, LocalProductGroup5
	, NativeProductCategoryKey
	, ProductCategoryBaseLevel
	, ProductCategoryLevel1
	, ProductCategoryLevel2
	, ProductCategoryLevel3
	, ProductCategoryLevel4
	, ProductCategoryLevel5
	, ProductCategoryLevel6
	)
	values
	(
	  src.ProductKey
	, src.IsDeleted
	, src.ProductNumber -- EtlDeltaHash
	, getdate() -- EtlCreatedOn
	, 'add seed values' -- EtlCreatedBy
	, getdate() -- EtlUpdatedOn
	, 'add seed values'  -- EtlUpdatedBy
	, null -- EtlDeletedOn
	, null -- EtlDeletedBy
	, src.QlikViewSourceSystemId
	, src.ProductNumber -- NativeProductKey
	, src.ProductNumber
	, src.ProductName
	, null -- ProductTypeId
	, src.ProductName -- ProductTypeName
	, '' -- ProductGnit
	, src.ProductDescription1
	, '' -- ProductDescription2
	, src.ProductName -- src.LocalProductGroup1
	, '' -- LocalProductGroup2
	, '' -- LocalProductGroup3
	, '' -- LocalProductGroup4
	, '' -- LocalProductGroup5
	, src.ProductNumber -- NativeProductCategoryKey
	, src.ProductName -- ProductCategoryBaseLevel
	, src.ProductName -- ProductCategoryLevel1
	, '' -- ProductCategoryLevel2
	, '' -- ProductCategoryLevel3
	, '' -- ProductCategoryLevel4
	, '' -- ProductCategoryLevel5
	, '' -- ProductCategoryLevel6
	)
when matched
	and tgt.IsDeleted <> src.IsDeleted
	or tgt.QlikViewSourceSystemId <> src.QlikViewSourceSystemId
	or tgt.ProductNumber <> src.ProductNumber
	or tgt.ProductName <> src.ProductName
	or tgt.ProductDescription1 <> src.ProductDescription1
then update
	set
		  tgt.IsDeleted = src.IsDeleted
		, tgt.EtlDeltaHash = src.ProductNumber
		, tgt.EtlUpdatedOn = getdate()
		, tgt.EtlUpdatedBy = 'update seed values' 
		, tgt.EtlDeletedOn = case when src.IsDeleted = 'Y' then getdate() else tgt.EtlDeletedOn end
		, tgt.EtlDeletedBy = case when src.IsDeleted = 'Y' then 'update seed values' else tgt.EtlDeletedBy end
		, tgt.QlikViewSourceSystemId = src.QlikViewSourceSystemId
		, tgt.NativeProductKey = src.ProductNumber
		, tgt.ProductNumber = src.ProductNumber
		, tgt.ProductName = src.ProductName
		, tgt.ProductTypeName = src.ProductName
		, tgt.ProductDescription1 = src.ProductDescription1
		, tgt.LocalProductGroup1 = src.ProductName
		, tgt.NativeProductCategoryKey = src.ProductNumber
		, tgt.ProductCategoryBaseLevel = src.ProductName
		, tgt.ProductCategoryLevel1 = src.ProductName
;
	
set identity_insert stg.Product off;
GO

set identity_insert stg.Customer on;
GO

;with sourceCte (CustomerKey, IsDeleted, QlikViewSourceSystemId, CustomerNumber, CustomerName, CustomerAddress1)
as
(
			  select -1, 'N', 100000, 'N/S', 'Not Specified at Source'	, 'Indicates that the value in the source system was NULL'
	union all select -2, 'N', 100000, 'N/F', 'Lookup Not Found'			, 'Indicates that the source system provided a value but that there is no matching lookup'
	union all select -3, 'N', 100000, 'N/I', 'Not Implemented in Source'	, 'Used when the source system does not support the concept of a Customer'
	union all select -4, 'N', 100000, 'N/A', 'Not Applicable'			, 'Used in a context where Customer has no relevance in this context'
	union all select -5, 'N', 100000, 'N/D', 'Not Defined'				, 'The logic to identify the Customer has not been supplied or specified'
)
merge into stg.Customer as tgt
using sourceCte as src
	on src.CustomerKey = tgt.CustomerKey
when not matched
	then insert
	(
	  CustomerKey
	, IsDeleted
	, EtlDeltaHash
	, EtlCreatedOn
	, EtlCreatedBy
	, EtlUpdatedOn
	, EtlUpdatedBy
	, EtlDeletedOn
	, EtlDeletedBy
	, QlikViewSourceSystemId
	, NativeCustomerKey
	, CustomerNumber
	, CustomerName
	, CustomerAddress1
	, CustomerAddress2
	, CustomerAddress3
	, CustomerZipCode
	, CustomerCity
	, CustomerCountry
	, CustomerVatNumber
	, CustomerTypeId
	, CustomerTypeName
	, CustomerGroup1
	, CustomerGroup2
	, CustomerGroup3
	, CustomerGroup4
	, CustomerGroup5
	, CategoryIsMapped
	, NativeCustomerCategoryKey
	, CustomerCategoryBaseLevel
	, CustomerCategoryLevel1
	, CustomerCategoryLevel2
	, CustomerCategoryLevel3
	, CustomerCategoryLevel4
	, CustomerCategoryLevel5
	, CustomerCategoryLevel6
	, CustomerCategoryLevel7
	, CustomerCategoryLevel8
	)
	values
	(
	  src.CustomerKey
	, src.IsDeleted
	, src.CustomerNumber -- EtlDeltaHash
	, getdate() -- EtlCreatedOn
	, 'add seed values' -- EtlCreatedBy
	, getdate() -- EtlUpdatedOn
	, 'add seed values'  -- EtlUpdatedBy
	, null -- EtlDeletedOn
	, null -- EtlDeletedBy
	, src.QlikViewSourceSystemId
	, src.CustomerNumber -- NativeCustomerKey
	, src.CustomerNumber
	, src.CustomerName

	, src.CustomerAddress1
	, '' -- CustomerAddress2
	, '' -- CustomerAddress3
	, src.CustomerNumber -- CustomerZipCode
	, src.CustomerName -- CustomerCity
	, src.CustomerNumber -- CustomerCountry
	, src.CustomerNumber -- CustomerVatNumber
	, null -- CustomerTypeId
	, src.CustomerName -- CustomerTypeName
	, src.CustomerName -- CustomerGroup1
	, '' -- CustomerGroup2
	, '' -- CustomerGroup3
	, '' -- CustomerGroup4
	, '' -- CustomerGroup5
	, '?' -- CategoryIsMapped
	, src.CustomerNumber -- NativeCustomerCategoryKey
	, src.CustomerName -- CustomerCategoryBaseLevel
	, src.CustomerName -- CustomerCategoryLevel1
	, '' -- CustomerCategoryLevel2
	, '' -- CustomerCategoryLevel3
	, '' -- CustomerCategoryLevel4
	, '' -- CustomerCategoryLevel5
	, '' -- CustomerCategoryLevel6
	, '' -- CustomerCategoryLevel7
	, '' -- CustomerCategoryLevel8
	)
when matched
	and tgt.IsDeleted <> src.IsDeleted
	or tgt.QlikViewSourceSystemId <> src.QlikViewSourceSystemId
	or tgt.CustomerNumber <> src.CustomerNumber
	or tgt.CustomerName <> src.CustomerName
	or tgt.CustomerAddress1 <> src.CustomerAddress1
then update
	set
		  tgt.IsDeleted = src.IsDeleted
		, tgt.EtlDeltaHash = src.CustomerNumber
		, tgt.EtlUpdatedOn = getdate()
		, tgt.EtlUpdatedBy = 'update seed values' 
		, tgt.EtlDeletedOn = case when src.IsDeleted = 'Y' then getdate() else tgt.EtlDeletedOn end
		, tgt.EtlDeletedBy = case when src.IsDeleted = 'Y' then 'update seed values' else tgt.EtlDeletedBy end
		, tgt.QlikViewSourceSystemId = src.QlikViewSourceSystemId
		, tgt.NativeCustomerKey = src.CustomerNumber -- NativeCustomerKey
		, tgt.CustomerNumber = src.CustomerNumber
		, tgt.CustomerName = src.CustomerName
		, tgt.CustomerAddress1 = src.CustomerAddress1
		, tgt.CustomerZipCode = src.CustomerNumber -- CustomerZipCode
		, tgt.CustomerCity = src.CustomerName -- CustomerCity
		, tgt.CustomerCountry = src.CustomerNumber -- CustomerCountry
		, tgt.CustomerVatNumber = src.CustomerNumber -- CustomerVatNumber
		, tgt.CustomerTypeName = src.CustomerName -- CustomerTypeName
		, tgt.CustomerGroup1 = src.CustomerName -- CustomerGroup1
		, tgt.NativeCustomerCategoryKey = src.CustomerNumber -- NativeCustomerCategoryKey
		, tgt.CustomerCategoryBaseLevel = src.CustomerName -- CustomerCategoryBaseLevel
		, tgt.CustomerCategoryLevel1 = src.CustomerName
;
	
set identity_insert stg.Customer off;
GO


set identity_insert stg.PaymentTerm on;
GO

;with sourceCte (PaymentTermKey, IsDeleted, PaymentTermCode, PaymentTermDays, PaymentTermName, PaymentTermDescription)
as
(
			  select -1, 'N', 'N/S'	, null, 'Not Specified at Source'	, 'Indicates that the value in the source system was NULL'
	union all select -2, 'N', 'N/F'	, null, 'Lookup Not Found'			, 'Indicates that the source system provided a value but that there is no matching lookup'
	union all select -3, 'N', 'N/I'	, null, 'Not Implemented in Source'	, 'Used when the source system does not support the concept of this static type'
	union all select -4, 'N', 'N/A'	, null, 'Not Applicable'			, 'Used in a context where this static type has no relevance in this context'
	union all select -5, 'N', 'N/D'	, null, 'Not Defined'				, 'The logic to identify the static type has not been supplied or specified'
)
merge into stg.PaymentTerm as tgt
using sourceCte as src
	on src.PaymentTermKey = tgt.PaymentTermKey
when not matched
	then insert
	(
	  PaymentTermKey
	, IsDeleted
	, EtlDeltaHash
	, EtlCreatedOn
	, EtlCreatedBy
	, EtlUpdatedOn
	, EtlUpdatedBy
	, EtlDeletedOn
	, EtlDeletedBy
	, NativePaymentTermKey
	, PaymentTermDays
	, PaymentTermName
	, PaymentTermDescription
	)
	values
	(
	  src.PaymentTermKey
	, src.IsDeleted
	, src.PaymentTermCode -- EtlDeltaHash
	, getdate() -- EtlCreatedOn
	, 'add seed values' -- EtlCreatedBy
	, getdate() -- EtlUpdatedOn
	, 'add seed values'  -- EtlUpdatedBy
	, null -- EtlDeletedOn
	, null -- EtlDeletedBy
	, src.PaymentTermCode
	, src.PaymentTermDays
	, src.PaymentTermName
	, src.PaymentTermDescription
	)
when matched
	and tgt.IsDeleted <> src.IsDeleted
	or coalesce(tgt.PaymentTermDays, -1) <> coalesce(src.PaymentTermDays, -1)
	or tgt.NativePaymentTermKey <> src.PaymentTermCode
	or tgt.PaymentTermName <> src.PaymentTermName
	or tgt.PaymentTermDescription <> src.PaymentTermDescription
then update
	set
		  tgt.IsDeleted = src.IsDeleted
		, tgt.EtlDeltaHash = src.PaymentTermDays
		, tgt.EtlUpdatedOn = getdate()
		, tgt.EtlUpdatedBy = 'update seed values' 
		, tgt.EtlDeletedOn = case when src.IsDeleted = 'Y' then getdate() else tgt.EtlDeletedOn end
		, tgt.EtlDeletedBy = case when src.IsDeleted = 'Y' then 'update seed values' else tgt.EtlDeletedBy end
		, tgt.NativePaymentTermKey = src.PaymentTermCode
		, tgt.PaymentTermDays = src.PaymentTermDays
		, tgt.PaymentTermName = src.PaymentTermName
		, tgt.PaymentTermDescription = src.PaymentTermDescription
;
	
set identity_insert stg.PaymentTerm off;
GO

set identity_insert stg.BusinessUnit on;
GO

;with sourceCte (BusinessUnitKey, IsDeleted, BusinessUnitCode, BusinessUnitName, BusinessUnitDescription)
as
(
			  select -1, 'N', 'N/S', 'Not Specified at Source'		, 'Indicates that the value in the source system was NULL'
	union all select -2, 'N', 'N/F', 'Lookup Not Found'				, 'Indicates that the source system provided a value but that there is no matching lookup'
	union all select -3, 'N', 'N/I', 'Not Implemented in Source'	, 'Used when the source system does not support the concept of a Business Unit'
	union all select -4, 'N', 'N/A', 'Not Applicable'				, 'Used in a context where Business Unit has no relevance in this context'
	union all select -5, 'N', 'N/D', 'Not Defined'					, 'The logic to identify the Business Unit has not been supplied or specified'
)
merge into stg.BusinessUnit as tgt
using sourceCte as src
	on src.BusinessUnitKey = tgt.BusinessUnitKey
when not matched
	then insert
	(
	  BusinessUnitKey
	, IsDeleted
	, EtlDeltaHash
	, EtlCreatedOn
	, EtlCreatedBy
	, EtlUpdatedOn
	, EtlUpdatedBy
	, EtlDeletedOn
	, EtlDeletedBy
	, NativeBusinessUnitKey
	, StrategicBusinessUnitCode
	, SalesCenterSbuCode
	, BusinessUnitName
	, RegionId
	, RegionName
	, RegionDescription
	)
	values
	(
	  src.BusinessUnitKey
	, src.IsDeleted
	, src.BusinessUnitCode -- EtlDeltaHash
	, getdate() -- EtlCreatedOn
	, 'add seed values' -- EtlCreatedBy
	, getdate() -- EtlUpdatedOn
	, 'add seed values'  -- EtlUpdatedBy
	, null -- EtlDeletedOn
	, null -- EtlDeletedBy
	, src.BusinessUnitCode -- NativeBusinessUnitKey
	, src.BusinessUnitCode -- StrategicBusinessUnitCode
	, src.BusinessUnitCode -- SalesCenterSbuCode
	, src.BusinessUnitName -- BusinessUnitName
	, null -- RegionId
	, src.BusinessUnitName -- RegionName
	, src.BusinessUnitDescription -- RegionDescription
	)
when matched
	and tgt.IsDeleted <> src.IsDeleted
	or tgt.NativeBusinessUnitKey <> src.BusinessUnitCode
	or tgt.BusinessUnitName <> src.BusinessUnitName
	or tgt.RegionDescription <> src.BusinessUnitDescription
	or tgt.StrategicBusinessUnitCode <> src.BusinessUnitCode
then update
	set
		  tgt.IsDeleted = src.IsDeleted
		, tgt.EtlDeltaHash = src.BusinessUnitCode
		, tgt.EtlUpdatedOn = getdate()
		, tgt.EtlUpdatedBy = 'update seed values' 
		, tgt.EtlDeletedOn = case when src.IsDeleted = 'Y' then getdate() else tgt.EtlDeletedOn end
		, tgt.EtlDeletedBy = case when src.IsDeleted = 'Y' then 'update seed values' else tgt.EtlDeletedBy end
		, tgt.NativeBusinessUnitKey = src.BusinessUnitCode
		, tgt.StrategicBusinessUnitCode = src.BusinessUnitCode
		, tgt.SalesCenterSbuCode = src.BusinessUnitCode
		, tgt.BusinessUnitName = src.BusinessUnitName
		, tgt.RegionName = src.BusinessUnitName
		, tgt.RegionDescription = src.BusinessUnitDescription
;
	
set identity_insert stg.BusinessUnit off;
GO

set identity_insert stg.[Site] on;
GO

;with sourceCte (SiteKey, IsDeleted, SiteCode, SiteName, SiteDescription)
as
(
			  select -1, 'N', 'N/S', 'Not Specified at Source'	, 'Indicates that the value in the source system was NULL'
	union all select -2, 'N', 'N/F', 'Lookup Not Found'			, 'Indicates that the source system provided a value but that there is no matching lookup'
	union all select -3, 'N', 'N/I', 'Not Implemented in Source'	, 'Used when the source system does not support the concept of a Site'
	union all select -4, 'N', 'N/A', 'Not Applicable'			, 'Used in a context where Site has no relevance in this context'
	union all select -5, 'N', 'N/D', 'Not Defined'				, 'The logic to identify the Site has not been supplied or specified'
)
merge into stg.[Site] as tgt
using sourceCte as src
	on src.SiteKey = tgt.SiteKey
when not matched
	then insert
	(
	  SiteKey
	, IsDeleted
	, EtlDeltaHash
	, EtlCreatedOn
	, EtlCreatedBy
	, EtlUpdatedOn
	, EtlUpdatedBy
	, EtlDeletedOn
	, EtlDeletedBy
	, NativeSiteKey
	, SiteName
	, SiteDescription
	, StrategicBusinessUnitCode
	, SalesCenterSbuCode
	, BusinessUnitName
	, RegionId
	, RegionName
	, RegionDescription
	, SourceSystemId
	, SourceSystemName
	)
	values
	(
	  src.SiteKey
	, src.IsDeleted
	, src.SiteCode -- EtlDeltaHash
	, getdate() -- EtlCreatedOn
	, 'add seed values' -- EtlCreatedBy
	, getdate() -- EtlUpdatedOn
	, 'add seed values'  -- EtlUpdatedBy
	, null -- EtlDeletedOn
	, null -- EtlDeletedBy
	, src.SiteCode -- NativeSiteKey
	, src.SiteName -- SiteName
	, src.SiteDescription -- SiteDescription
	, src.SiteCode -- StrategicBusinessUnitCode
	, src.SiteCode -- SalesCenterSbuCode
	, src.SiteName -- BusinessUnitName
	, null -- RegionId
	, src.SiteName -- RegionName
	, '' -- RegionDescription
	, null -- SourceSystemId
	, src.SiteName -- SourceSystemName
	)
when matched
	and tgt.IsDeleted <> src.IsDeleted
	or tgt.NativeSiteKey <> src.SiteCode
	or tgt.SiteName <> src.SiteName
	or tgt.SiteDescription <> src.SiteDescription
	or tgt.StrategicBusinessUnitCode <> src.SiteCode
then update
	set
		  tgt.IsDeleted = src.IsDeleted
		, tgt.EtlDeltaHash = src.SiteCode
		, tgt.EtlUpdatedOn = getdate()
		, tgt.EtlUpdatedBy = 'update seed values' 
		, tgt.EtlDeletedOn = case when src.IsDeleted = 'Y' then getdate() else tgt.EtlDeletedOn end
		, tgt.EtlDeletedBy = case when src.IsDeleted = 'Y' then 'update seed values' else tgt.EtlDeletedBy end
		, tgt.NativeSiteKey = src.SiteCode
		, tgt.SiteName = src.SiteName
		, tgt.SiteDescription = src.SiteDescription
		, tgt.StrategicBusinessUnitCode = src.SiteCode
		, tgt.SalesCenterSbuCode = src.SiteCode
		, tgt.BusinessUnitName = src.SiteName
		, tgt.RegionName = src.SiteName
		, tgt.SourceSystemName = src.SiteName
;
	
set identity_insert stg.Site off;
GO


GO

GO
PRINT N'Update complete.';


GO
